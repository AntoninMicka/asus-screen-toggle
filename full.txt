--- PROJECT EXPORT ---
Working Directory: /home/tonda/Dokumenty/Clanek-ZEnbook-Duo/asus-screen-toggle

üìÅ PROJECT STRUCTURE:
.
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ TODO.txt
‚îú‚îÄ‚îÄ assets
‚îÇ   ‚îú‚îÄ‚îÄ menu_items.png
‚îÇ   ‚îú‚îÄ‚îÄ settings_hw.png
‚îÇ   ‚îú‚îÄ‚îÄ settings_main.png
‚îÇ   ‚îú‚îÄ‚îÄ settings_services.png
‚îÇ   ‚îî‚îÄ‚îÄ statbar_icon.png
‚îú‚îÄ‚îÄ asus-screen-toggle
‚îÇ   ‚îú‚îÄ‚îÄ Makefile
‚îÇ   ‚îú‚îÄ‚îÄ build.conf
‚îÇ   ‚îú‚îÄ‚îÄ src
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bin
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ asus-check-keyboard-system.sh.in
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ channels
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dbus.sh
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ direct.sh
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ noop-debug.sh
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signal.sh
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ systemd.sh
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ helpers.sh
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lib
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ systemd
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ user
‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ asus-screen-toggle.service
‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ asus-user-agent.service
‚îÇ   ‚îî‚îÄ‚îÄ usr
‚îÇ       ‚îú‚îÄ‚îÄ bin
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ asus-check-keyboard-genrules.sh
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ asus-check-keyboard-user.sh
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ asus-check-rotation.sh
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ asus-screen-settings.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ asus-screen-toggle-launcher.sh
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ asus-user-agent.py
‚îÇ       ‚îú‚îÄ‚îÄ lib
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ systemd
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ system
‚îÇ       ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ asus-bottom-screen-init.service
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ system-sleep
‚îÇ       ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ 99-asus-screen-resume
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ user
‚îÇ       ‚îî‚îÄ‚îÄ share
‚îÇ           ‚îú‚îÄ‚îÄ 99-asus-keyboard.rules.template
‚îÇ           ‚îú‚îÄ‚îÄ applications
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ asus-screen-settings.desktop
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ asus-screen-toggle-agent.desktop
‚îÇ           ‚îú‚îÄ‚îÄ asus-screen-toggle
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ icon-blue.svg
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ icon-green.svg
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ icon-red.svg
‚îÇ           ‚îî‚îÄ‚îÄ man
‚îÇ               ‚îî‚îÄ‚îÄ man1
‚îÇ                   ‚îú‚îÄ‚îÄ asus-check-keyboard-genrules.1
‚îÇ                   ‚îú‚îÄ‚îÄ asus-check-keyboard-system.1
‚îÇ                   ‚îú‚îÄ‚îÄ asus-check-keyboard-user.1
‚îÇ                   ‚îú‚îÄ‚îÄ asus-check-rotation.1
‚îÇ                   ‚îú‚îÄ‚îÄ asus-screen-settings.1
‚îÇ                   ‚îú‚îÄ‚îÄ asus-screen-toggle-launcher.1
‚îÇ                   ‚îú‚îÄ‚îÄ asus-user-agent.1
‚îÇ                   ‚îî‚îÄ‚îÄ cs
‚îÇ                       ‚îú‚îÄ‚îÄ asus-check-keyboard-genrules.1
‚îÇ                       ‚îú‚îÄ‚îÄ asus-check-keyboard-system.1
‚îÇ                       ‚îú‚îÄ‚îÄ asus-check-keyboard-user.1
‚îÇ                       ‚îú‚îÄ‚îÄ asus-check-rotation.1
‚îÇ                       ‚îú‚îÄ‚îÄ asus-screen-settings.1
‚îÇ                       ‚îú‚îÄ‚îÄ asus-screen-toggle-launcher.1
‚îÇ                       ‚îî‚îÄ‚îÄ asus-user-agent.1
‚îú‚îÄ‚îÄ asus-screen-toggle.cflags
‚îú‚îÄ‚îÄ asus-screen-toggle.config
‚îú‚îÄ‚îÄ asus-screen-toggle.creator
‚îú‚îÄ‚îÄ asus-screen-toggle.creator.user
‚îú‚îÄ‚îÄ asus-screen-toggle.cxxflags
‚îú‚îÄ‚îÄ asus-screen-toggle.files
‚îú‚îÄ‚îÄ asus-screen-toggle.includes
‚îú‚îÄ‚îÄ asus-screen-toggle_1.1.1.orig.tar.gz
‚îú‚îÄ‚îÄ backup&devutils
‚îÇ   ‚îú‚îÄ‚îÄ asus-bottom-screen-loged.service
‚îÇ   ‚îú‚îÄ‚îÄ asus-check-keyboard-kscreen-and-xrandr.sh
‚îÇ   ‚îú‚îÄ‚îÄ asus-check-keyboard-kscreen.sh
‚îÇ   ‚îú‚îÄ‚îÄ asus-check-keyboard-wlr-randr.sh
‚îÇ   ‚îú‚îÄ‚îÄ asus-check-keyboard-xrandr.sh
‚îÇ   ‚îú‚îÄ‚îÄ asus-check-keyboard.sh
‚îÇ   ‚îú‚îÄ‚îÄ asus-user-agent.sh
‚îÇ   ‚îú‚îÄ‚îÄ detect-sessions-message.sh
‚îÇ   ‚îú‚îÄ‚îÄ detect-sessions.sh
‚îÇ   ‚îî‚îÄ‚îÄ screen_size.sh
‚îú‚îÄ‚îÄ build
‚îÇ   ‚îî‚îÄ‚îÄ locale
‚îÇ       ‚îú‚îÄ‚îÄ ar
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ LC_MESSAGES
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ asus-screen-toggle.mo
‚îÇ       ‚îú‚îÄ‚îÄ cs
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ LC_MESSAGES
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ asus-screen-toggle.mo
‚îÇ       ‚îú‚îÄ‚îÄ en
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ LC_MESSAGES
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ asus-screen-toggle.mo
‚îÇ       ‚îú‚îÄ‚îÄ es
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ LC_MESSAGES
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ asus-screen-toggle.mo
‚îÇ       ‚îú‚îÄ‚îÄ fr
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ LC_MESSAGES
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ asus-screen-toggle.mo
‚îÇ       ‚îú‚îÄ‚îÄ ja
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ LC_MESSAGES
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ asus-screen-toggle.mo
‚îÇ       ‚îú‚îÄ‚îÄ pt
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ LC_MESSAGES
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ asus-screen-toggle.mo
‚îÇ       ‚îî‚îÄ‚îÄ zh
‚îÇ           ‚îî‚îÄ‚îÄ LC_MESSAGES
‚îÇ               ‚îî‚îÄ‚îÄ asus-screen-toggle.mo
‚îú‚îÄ‚îÄ compile_locales.sh
‚îú‚îÄ‚îÄ debian
‚îÇ   ‚îú‚îÄ‚îÄ asus-screen-toggle
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ usr
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ bin
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ asus-check-keyboard-user
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ asus-screen-settings
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ asus-user-agent
‚îÇ   ‚îú‚îÄ‚îÄ changelog
‚îÇ   ‚îú‚îÄ‚îÄ clean
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îú‚îÄ‚îÄ control
‚îÇ   ‚îú‚îÄ‚îÄ copyright
‚îÇ   ‚îú‚îÄ‚îÄ debhelper-build-stamp
‚îÇ   ‚îú‚îÄ‚îÄ install
‚îÇ   ‚îú‚îÄ‚îÄ patches
‚îÇ   ‚îú‚îÄ‚îÄ po
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ POTFILES.in
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cs.po
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ templates.pot
‚îÇ   ‚îú‚îÄ‚îÄ postinst
‚îÇ   ‚îú‚îÄ‚îÄ postrm
‚îÇ   ‚îú‚îÄ‚îÄ rules
‚îÇ   ‚îú‚îÄ‚îÄ source
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ format
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ options
‚îÇ   ‚îú‚îÄ‚îÄ templates
‚îÇ   ‚îú‚îÄ‚îÄ upstream
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metadata
‚îÇ   ‚îî‚îÄ‚îÄ watch
‚îú‚îÄ‚îÄ docs
‚îÇ   ‚îú‚îÄ‚îÄ RELEASE.md
‚îÇ   ‚îú‚îÄ‚îÄ asus-screen-settings.html
‚îÇ   ‚îú‚îÄ‚îÄ asus-user-agent.html
‚îÇ   ‚îú‚îÄ‚îÄ index.cs.html
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ full.txt
‚îú‚îÄ‚îÄ gen_locales.sh
‚îú‚îÄ‚îÄ po
‚îÇ   ‚îú‚îÄ‚îÄ ar.po
‚îÇ   ‚îú‚îÄ‚îÄ asus-screen-toggle.pot
‚îÇ   ‚îú‚îÄ‚îÄ cs.po
‚îÇ   ‚îú‚îÄ‚îÄ en.po
‚îÇ   ‚îú‚îÄ‚îÄ es.po
‚îÇ   ‚îú‚îÄ‚îÄ fr.po
‚îÇ   ‚îú‚îÄ‚îÄ ja.po
‚îÇ   ‚îú‚îÄ‚îÄ pt.po
‚îÇ   ‚îî‚îÄ‚îÄ zh.po
‚îú‚îÄ‚îÄ release.sh
‚îî‚îÄ‚îÄ release_local.sh


================================================================================

üìÑ PATH: README.md
--------------------------------------------------------------------------------
Asus Screen Toggle

Automatic secondary display management for Asus Zenbook Duo laptops on Linux (KDE/Debian).

Debian Mentors: https://mentors.debian.net/package/asus-screen-toggle/ ITP Bug: https://bugs.debian.org/1124010
Overview

This utility monitors your hardware state (lid status and external keyboard connection) to automatically enable or disable the secondary screen. It is specifically designed for the Asus Zenbook Duo (2024) UX8406.
Key Features

    Automatic Toggle: Enables/disables the bottom screen based on the keyboard connection.

    Smart Orientation: Full support for screen rotation via iio-sensor-proxy.

    User Interface: A GTK3 settings app and a system tray agent for manual overrides.

    Debian Integrated: Developed following Debian packaging standards.

Installation (Debian/KDE)

The package is currently in the process of being included in the official Debian repositories. You can download the latest version from Debian Mentors.
Build from source

    sudo apt install devscripts build-essential

    git clone https://github.com/antoninmicka/asus-screen-toggle

    cd asus-screen-toggle

    mk-build-deps -ir

    dpkg-buildpackage -us -uc

    sudo apt install ../asus-screen-toggle_*.deb

Documentation

Detailed documentation is available via manual pages:

    man asus-user-agent

    man asus-screen-settings

Or visit the Project Website: https://antoninmicka.github.io/asus-screen-toggle/
Compatibility

    Environment: Debian Sid/Testing/12 with KDE Plasma.

    Hardware: Asus Zenbook Duo (2024) UX8406.

    Dependencies: python3-gi, pydbus, gir1.2-appindicator3-0.1, iio-sensor-proxy.

License

This project is licensed under the GPL-3.0 License. Part of the Asus-Linux (https://asus-linux.org) community efforts.


================================================================================

üìÑ PATH: gen_locales.sh
--------------------------------------------------------------------------------
#!/bin/bash
# Skript pro generov√°n√≠ a aktualizaci p≈ôeklad≈Ø (gettext)

DOMAIN="asus-screen-toggle"
LOCALE_DIR="po"
FILES_PY="asus-screen-toggle/usr/bin/*.py"
FILES_SH="asus-screen-toggle/usr/bin/*.sh"

mkdir -p "$LOCALE_DIR"

echo "1. Extrahov√°n√≠ ≈ôetƒõzc≈Ø z Pythonu a Shellu..."
# Vytvo≈ôen√≠ ≈°ablony (.pot)
# -k_: Kl√≠ƒçov√© slovo pro python je _
# --from-code=UTF-8: K√≥dov√°n√≠
xgettext -L Python -k_ -o "$LOCALE_DIR/$DOMAIN.pot" $FILES_PY --from-code=UTF-8
# P≈ôipoj√≠me ≈ôetƒõzce ze Shell skript≈Ø (-j = join)
xgettext -L Shell -k_ -j -o "$LOCALE_DIR/$DOMAIN.pot" $FILES_SH --from-code=UTF-8

echo "≈†ablona vytvo≈ôena: $LOCALE_DIR/$DOMAIN.pot"

# Seznam jazyk≈Ø
LANGS=("en" "cs" "fr" "es" "pt" "zh" "ja" "ar")

for lang in "${LANGS[@]}"; do
    PO_FILE="$LOCALE_DIR/$lang.po"

    if [ -f "$PO_FILE" ]; then
        echo "Aktualizuji $lang.po ..."
        msgmerge -U "$PO_FILE" "$LOCALE_DIR/$DOMAIN.pot"
    else
        echo "Vytv√°≈ô√≠m nov√Ω $lang.po ..."
        msginit --no-translator -l "$lang" -o "$PO_FILE" -i "$LOCALE_DIR/$DOMAIN.pot"
    fi
done

echo "Hotovo. Nyn√≠ upravte soubory .po v adres√°≈ôi $LOCALE_DIR/ a dopl≈àte p≈ôeklady."
echo "Pro kompilaci (test) spus≈•te: bash compile_locales.sh"


================================================================================

üìÑ PATH: release.sh
--------------------------------------------------------------------------------
#!/usr/bin/env bash
set -euo pipefail

die() { echo "ERROR: $*" >&2; exit 1; }

MODE=""
VERSION=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --patch|--minor|--major) MODE="${1#--}" ;;
    --version) VERSION="$2"; shift ;;
    *) die "Unknown argument $1" ;;
  esac
  shift
done

git diff --quiet || die "Working tree not clean"

LAST=$(git tag --sort=-v:refname | grep '^v' | head -n1 | sed 's/^v//')

if [[ -z "$VERSION" ]]; then
  [[ -z "$MODE" ]] && die "Use --patch / --minor / --major or --version"
  IFS=. read -r M m p <<<"$LAST"
  case "$MODE" in
    patch) p=$((p+1)) ;;
    minor) m=$((m+1)); p=0 ;;
    major) M=$((M+1)); m=0; p=0 ;;
  esac
  VERSION="$M.$m.$p"
fi

DEB_VERSION="$VERSION-1"

echo "Releasing $VERSION"

dch -v "$DEB_VERSION"
git commit -am "Release $VERSION"

git tag "v$VERSION"
git push origin main --tags

echo "Tag v$VERSION pushed ‚Äì GitHub CI will validate the source."


================================================================================

üìÑ PATH: compile_locales.sh
--------------------------------------------------------------------------------
#!/bin/bash
# gen_locales.sh
# Skript pro extrakci text≈Ø a aktualizaci .po soubor≈Ø

DOMAIN="asus-screen-toggle"
PO_DIR="po"
SRC_DIR="asus-screen-toggle/usr/bin"

# Seznam podporovan√Ωch jazyk≈Ø
LANGS=("en" "cs" "fr" "es" "pt" "zh" "ja" "ar")

mkdir -p "$PO_DIR"

echo "1. Extrahov√°n√≠ ≈ôetƒõzc≈Ø..."

# Vytvo≈ôen√≠ ≈°ablony (.pot)
# Python soubory
xgettext -L Python -k_ --from-code=UTF-8 -o "$PO_DIR/$DOMAIN.pot" "$SRC_DIR"/*.py

# Bash soubory (p≈ôipoj√≠me k existuj√≠c√≠ ≈°ablonƒõ pomoc√≠ -j)
xgettext -L Shell -k_ --from-code=UTF-8 -j -o "$PO_DIR/$DOMAIN.pot" "$SRC_DIR"/*.sh

echo "≈†ablona vytvo≈ôena: $PO_DIR/$DOMAIN.pot"

# Aktualizace/Vytvo≈ôen√≠ .po soubor≈Ø pro jednotliv√© jazyky
for lang in "${LANGS[@]}"; do
    PO_FILE="$PO_DIR/$lang.po"

    if [ -f "$PO_FILE" ]; then
        echo "üîÑ Aktualizuji $lang.po ..."
        msgmerge -U --backup=none "$PO_FILE" "$PO_DIR/$DOMAIN.pot"
    else
        echo "‚ú® Vytv√°≈ô√≠m nov√Ω $lang.po ..."
        msginit --no-translator -l "$lang" -o "$PO_FILE" -i "$PO_DIR/$DOMAIN.pot"

        # Oprava charsetu, msginit nƒõkdy nastav√≠ ASCII
        sed -i 's/Content-Type: text\/plain; charset=ASCII/Content-Type: text\/plain; charset=UTF-8/' "$PO_FILE"
    fi
done

echo "‚úÖ Hotovo. Nyn√≠ p≈ôelo≈æte soubory v adres√°≈ôi $PO_DIR/"


================================================================================

üìÑ PATH: CONTRIBUTING.md
--------------------------------------------------------------------------------
# Contributing to Asus Screen Toggle

First of all, thank you for considering contributing to this project! It's people like you that make the Linux ecosystem on Asus laptops better.

## How Can I Contribute?

### Reporting Bugs
- Check the [Issues](../../issues) tab to see if the bug has already been reported.
- If not, open a new issue. Include your laptop model, Linux distribution, and desktop environment (KDE/GNOME/etc.).
- Provide logs if possible: `journalctl -u asus-screen-toggle`.

### Suggesting Enhancements
- Open an issue with the tag `enhancement`.
- Describe the feature and why it would be useful.

### Pull Requests
1. Fork the repository.
2. Create a new branch for your feature (`git checkout -b feature/amazing-feature`).
3. Commit your changes.
4. Push to the branch.
5. Open a Pull Request.

## Code Style
- **Python:** Please follow PEP 8.
- **Shell:** Use `shellcheck` before submitting scripts.
- **Translations:** If you want to add a new language, look into the `po/` directory.

## License
By contributing, you agree that your contributions will be licensed under its GPL-3.0 License.


================================================================================

üìÑ PATH: release_local.sh
--------------------------------------------------------------------------------
#!/usr/bin/env bash
set -euo pipefail

PROJECT="asus-screen-toggle"

# ---------- helpers ----------
die() { echo "ERROR: $*" >&2; exit 1; }

require_clean_git() {
    git diff --quiet || die "Working tree is dirty"
    git diff --cached --quiet || die "Index is dirty"
}

get_last_version() {
    git tag --sort=-v:refname | grep '^v' | head -n1 | sed 's/^v//'
}

bump_version() {
    local v=$1 mode=$2
    IFS=. read -r major minor patch <<<"$v"
    case "$mode" in
        patch) patch=$((patch+1)) ;;
        minor) minor=$((minor+1)); patch=0 ;;
        major) major=$((major+1)); minor=0; patch=0 ;;
        *) die "Unknown bump mode: $mode" ;;
    esac
    echo "$major.$minor.$patch"
}

pick_gpg_key() {
    mapfile -t KEYS < <(gpg --list-secret-keys --keyid-format LONG \
        | awk '/^sec/{print $2}' | cut -d/ -f2)

    [[ ${#KEYS[@]} -eq 0 ]] && die "No GPG keys found"

    if [[ ${#KEYS[@]} -eq 1 ]]; then
        echo "${KEYS[0]}"
        return
    fi

    echo "Select GPG key:"
    select k in "${KEYS[@]}"; do
        echo "$k"
        return
    done
}

# ---------- args ----------
MODE=""
VERSION=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --patch|--minor|--major) MODE="${1#--}" ;;
        --version) VERSION="$2"; shift ;;
        *) die "Unknown argument $1" ;;
    esac
    shift
done

# ---------- main ----------
require_clean_git

LAST=$(get_last_version)
[[ -z "$LAST" && -z "$VERSION" ]] && die "No previous tag, use --version"

if [[ -z "$VERSION" ]]; then
    [[ -z "$MODE" ]] && die "Use --patch / --minor / --major or --version"
    VERSION=$(bump_version "$LAST" "$MODE")
fi

DEB_VERSION="${VERSION}-1"
TAG="v$VERSION"

echo "Releasing version $VERSION"

git tag "$TAG"

ORIG="../${PROJECT}_${VERSION}.orig.tar.gz"

git archive \
  --format=tar.gz \
  --prefix="${PROJECT}-${VERSION}/" \
  "$TAG" > "$ORIG"

dch -v "$DEB_VERSION"

rm -rf .pc debian/patches/*.rej || true

KEY=$(pick_gpg_key)

dpkg-buildpackage -S -sa "-k$KEY"

dput mentors "../${PROJECT}_${DEB_VERSION}_source.changes"

echo "Release $VERSION uploaded successfully"


================================================================================

üìÑ PATH: docs/RELEASE.md
--------------------------------------------------------------------------------
# üìå Release workflow ‚Äì z√°kladn√≠ pravidla

## V√Ωznam vƒõtv√≠
- develop
 - bƒõ≈æn√Ω v√Ωvoj
 - experimenty, feature vƒõtve
 - nikdy se z n√≠ nevyd√°v√°
- release/*
 - p≈ô√≠prava vyd√°n√≠
 - stabilizace, ladƒõn√≠
 - CI ovƒõ≈ôuje releasovatelnost
- hotfix/*
 - opravy vydan√Ωch verz√≠
 - CI ovƒõ≈ôuje releasovatelnost
- main
 - obsahuje pouze vydan√© verze
 - ka≈æd√Ω commit odpov√≠d√° jednomu vyd√°n√≠
 - v≈ædy oznaƒçen√Ω tagem

- Release a hotfix vƒõtve maj√≠ tvar release/X.Y nebo hotfix/X.Y.
- N√°zev vƒõtve neurƒçuje konkr√©tn√≠ verzi bal√≠ku.
- Konkr√©tn√≠ upstream verze je urƒçena v√Ωhradnƒõ git tagem.
 
## Pravidla pro vyd√°n√≠
- vyd√°n√≠ prob√≠h√° v√Ωhradnƒõ merge do main
- do main se:
 - nepushuje p≈ô√≠mo
 - merguje se pouze p≈ôes PR
- stav v main:
 - pro≈°el CI
 - je stabiln√≠
 - je vhodn√Ω k vyd√°n√≠

- Release a hotfix vƒõtve maj√≠ tvar release/X.Y nebo hotfix/X.Y.
- CI odm√≠tne jakoukoli vƒõtev s jin√Ωm n√°zvem.
- P≈ôi vyd√°n√≠ se kontroluje, ≈æe upstream verze odpov√≠d√° vƒõtvi (X.Y.Z ‚àà X.Y.x).

## Tagov√°n√≠
- ka≈æd√Ω release commit v main:
 - m√° odpov√≠daj√≠c√≠ git tag vX.Y.Z
- tagy:
 - se vytv√°≈ô√≠ pouze nad main
 - nikdy nad develop nebo release/*

## Debian balen√≠
- main je jedin√Ω zdroj pravdy pro:
 - orig.tar.gz
 - Debian source bal√≠k
- upstream tarball:
 - vznik√° z git tagu
 - ne z pracovn√≠ho stromu

## Automatizace (zat√≠m ne≈ôe≈°√≠ detaily)
- CI:
 - ovƒõ≈ôuje ka≈æd√Ω commit v release/* a hotfix/*
- upload:
 - prob√≠h√° lok√°lnƒõ z maintainerova stroje
 - po merge do main

# ü•à CI jako gate pro release/* a hotfix/*
- Ka≈æd√Ω commit v release/* a hotfix/* mus√≠ proj√≠t CI.
- CI ovƒõ≈ôuje, ≈æe zdroj lze zabalit a znovu rozbalit jako Debian source bal√≠k.
- Pokud CI sel≈æe, zmƒõna nesm√≠ b√Ωt mergnuta do main.

# ü•â Lok√°ln√≠ publish krok (maintainer-controlled release)
- Vyd√°n√≠ bal√≠ku se prov√°d√≠ lok√°lnƒõ z poƒç√≠taƒçe maintainera.
- Publish krok prob√≠h√° pouze po merge do main.
- Publish zahrnuje tagov√°n√≠, vytvo≈ôen√≠ Debian source bal√≠ku, podpis a upload.
- CI ani GitHub nikdy bal√≠k nepodepisuj√≠ ani nenahr√°vaj√≠.

# üè∑Ô∏è Git tag jako jedin√Ω zdroj pravdy
- Ka≈æd√© vyd√°n√≠ je identifikov√°no git tagem vX.Y.Z.
- Upstream tarball (orig.tar.gz) mus√≠ b√Ωt vytvo≈ôen v√Ωhradnƒõ z tohoto tagu.
- Debian source bal√≠k mus√≠ odpov√≠dat tomuto tarballu.
- Pracovn√≠ strom ani jin√© vƒõtve nejsou zdrojem vyd√°n√≠.

# üî¢ V√Ωznam verz√≠ (upstream vs Debian)
- Upstream verze (X.Y.Z) popisuje stav projektu a je reprezentov√°na git tagem.
- Debian revize (-N) popisuje zmƒõny v balen√≠ a nemƒõn√≠ upstream k√≥d.
- Zmƒõna upstream verze v≈ædy znamen√° nov√Ω tag.
- Zmƒõna Debian revize nikdy neznamen√° nov√Ω tag.

# ü©π Hotfix vƒõtve a backporty
- Hotfix vƒõtve se vytv√°≈ôej√≠ z vydan√© verze (main / tag).
- Slou≈æ√≠ pouze k oprav√°m chyb ve vydan√©m k√≥du.
- Hotfix zvy≈°uje upstream patch verzi.
- Hotfix se po vyd√°n√≠ merguje zpƒõt do develop.

# üõ°Ô∏è Ochrana vƒõtv√≠ a role maintainer≈Ø
- Vyd√°n√≠ bal√≠k≈Ø prov√°d√≠ pouze maintainer.
- Vƒõtev main je chr√°nƒõn√° a obsahuje pouze vydan√© verze.
- P≈ô√≠m√© pushov√°n√≠ do main nen√≠ povoleno.
- Ka≈æd√© vyd√°n√≠ je vƒõdom√© rozhodnut√≠ maintainera.

# üîÑ Chyby, opravy a rollback
- Vydan√© verze se nikdy nemƒõn√≠ ani nep≈ôepisuj√≠.
- Chyby po vyd√°n√≠ se ≈ôe≈°√≠ nov√Ωm vyd√°n√≠m (hotfix nebo nov√° Debian revize).
- Tagy a historie se nikdy nema≈æou ani nep≈ôepisuj√≠.
- Rollback znamen√° vyd√°n√≠ opraven√© verze, nikoli n√°vrat v historii.


================================================================================

üìÑ PATH: asus-screen-toggle/usr/bin/asus-screen-settings.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import sys
import os
import subprocess
import gi
import gettext
import locale
import shutil

# Nastaven√≠ lokalizace
APP_NAME = "asus-screen-toggle"
LOCALE_DIR = "/usr/share/locale"

try:
    # Pokus√≠me se nastavit syst√©movou locale
    locale.setlocale(locale.LC_ALL, '')

    # Inicializace gettext
    gettext.bindtextdomain(APP_NAME, LOCALE_DIR)
    gettext.textdomain(APP_NAME)
    _ = gettext.gettext
except Exception as e:
    # Fallback, pokud gettext sel≈æe (nap≈ô. p≈ôi v√Ωvoji mimo instalaci)
    print(f"Warning: Localization not loaded: {e}")
    _ = lambda s: s

try:
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, GLib, GdkPixbuf
except ValueError:
    print(_("Error: Gtk 3.0 not found."))
    sys.exit(1)

# Pokus o import pydbus pro komunikaci s Agentem
try:
    from pydbus import SessionBus
    DBUS_AVAILABLE = True
except ImportError:
    DBUS_AVAILABLE = False
    print(_("Warning: pydbus not found. Direct D-Bus communication disabled."))

# --- Konstanty ---
APP_TITLE = _("Nastaven√≠ Asus Screen Toggle")
BUS_NAME = "org.asus.ScreenToggle" # D-Bus jm√©no agenta
USER_SERVICE = "asus-screen-toggle.service"
SYSTEM_SERVICE = "asus-bottom-screen-init.service"
SYSTRAY_SERVICE = "asus-user-agent.service"

# Cesty ke konfigurac√≠m
SYSTEM_CONFIG_FILE = "/etc/asus-screen-toggle.conf"
USER_CONFIG_FILE = os.path.expanduser("~/.config/asus-screen-toggle/user.conf")

# Cesty pro logiku p≈ôep√≠n√°n√≠ (stejn√© jako v User Agent)
STATE_DIR = os.path.expanduser("~/.local/state/asus-check-keyboard")
STATE_FILE = os.path.join(STATE_DIR, "state")
SCRIPT_PATH = shutil.which("asus-check-keyboard-user") or "/usr/bin/asus-check-keyboard-user"

GENRULES_PATH = shutil.which("asus-check-keyboard-genrules") or "/usr/bin/asus-check-keyboard-genrules"

# Cesty k ikon√°m
ICON_PATH = "/usr/share/asus-screen-toggle"
ICON_AUTO = os.path.join(ICON_PATH, "icon-green.svg")
ICON_PRIMARY = os.path.join(ICON_PATH, "icon-red.svg")
ICON_DESKTOP = os.path.join(ICON_PATH, "icon-blue.svg")

class AsusSettingsApp(Gtk.Window):
    def __init__(self):
        super().__init__(title=APP_TITLE)
        self.set_border_width(10)
        self.set_default_size(650, 600)
        self.set_position(Gtk.WindowPosition.CENTER)

        # Notebook s kartami
        self.notebook = Gtk.Notebook()

        # Layout
        main_layout = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(main_layout)
        main_layout.pack_start(self.notebook, True, True, 0)

        # --- KARTA 0: DOM≈Æ (Rychl√© ovl√°d√°n√≠) ---
        self.page_home = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        self.page_home.set_border_width(20)
        self.notebook.append_page(self.page_home, Gtk.Label(label="Dom≈Ø"))

        # Nadpis
        lbl_welcome = Gtk.Label(label=_("<span size='x-large' weight='bold'>Rychl√© ovl√°d√°n√≠</span>"))
        lbl_welcome.set_use_markup(True)
        self.page_home.pack_start(lbl_welcome, False, False, 10)

        hbox_modes = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=20)
        hbox_modes.set_halign(Gtk.Align.CENTER)
        self.page_home.pack_start(hbox_modes, True, True, 0)

        # 1. Tlaƒç√≠tko AUTO
        self.btn_mode_auto = self.create_mode_button(_("Automaticky"), ICON_AUTO, _("Senzory"), "automatic-enabled")
        hbox_modes.pack_start(self.btn_mode_auto, True, True, 0)

        # 2. Tlaƒç√≠tko PRIMARY
        self.btn_mode_primary = self.create_mode_button(_("Jen Hlavn√≠"), ICON_PRIMARY, _("Vypnout spodn√≠"), "enforce-primary-only")
        hbox_modes.pack_start(self.btn_mode_primary, True, True, 0)

        # 3. Tlaƒç√≠tko DESKTOP
        self.btn_mode_desktop = self.create_mode_button(_("Oba Displeje"), ICON_DESKTOP, _("Vynutit zapnut√≠"), "enforce-desktop")
        hbox_modes.pack_start(self.btn_mode_desktop, True, True, 0)

        # Oddƒõlovaƒç
        self.page_home.pack_start(Gtk.Separator(), False, False, 10)

        # Tlaƒç√≠tko Kontrola
        btn_check = Gtk.Button(label=_("üîÑ Spustit okam≈æitou kontrolu"))
        btn_check.set_property("width-request", 300)
        btn_check.set_halign(Gtk.Align.CENTER)
        btn_check.get_style_context().add_class("suggested-action") # Modr√© zv√Ωraznƒõn√≠
        btn_check.connect("clicked", lambda x: self.run_check())
        self.page_home.pack_start(btn_check, False, False, 10)

        # --- KARTA 1: OBECN√â (Slu≈æby a u≈æivatelsk√© chov√°n√≠) ---
        self.page_general = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.page_general.set_border_width(10)
        self.notebook.append_page(self.page_general, Gtk.Label(label=_("Slu≈æby & Config")))

        # 1. Sekce: Spr√°va Slu≈æeb
        frame_services = Gtk.Frame(label=_("Stav Slu≈æeb"))
        self.page_general.pack_start(frame_services, False, False, 0)

        vbox_services = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        vbox_services.set_border_width(10)
        frame_services.add(vbox_services)

        # User Service
        self.status_user = Gtk.Label(label="...")
        self.btn_user_toggle = Gtk.Button(label="...")
        self.btn_user_toggle.connect("clicked", self.on_user_service_toggle)
        self.switch_user_enable = Gtk.Switch()
        self.switch_user_enable.connect("notify::active", self.on_user_enable_toggle)
        vbox_services.pack_start(self.create_service_row(_("U≈æivatelsk√° slu≈æba (Agent)"), self.status_user, self.btn_user_toggle, self.switch_user_enable), False, False, 0)

        vbox_services.pack_start(Gtk.Separator(), False, False, 5)
        self.status_systray = Gtk.Label(label="...")
        self.btn_systray_toggle = Gtk.Button(label="...")
        self.btn_systray_toggle.connect("clicked", self.on_systray_service_toggle)
        self.switch_systray_enable = Gtk.Switch()
        self.switch_systray_enable.connect("notify::active", self.on_systray_enable_toggle)
        vbox_services.pack_start(self.create_service_row(_("Indik√°tor stauu (Systray)"), self.status_systray, self.btn_systray_toggle, self.switch_systray_enable), False, False, 0)

        vbox_services.pack_start(Gtk.Separator(), False, False, 5)

        # System Service
        self.status_system = Gtk.Label(label="...")
        self.btn_system_toggle = Gtk.Button(label="...")
        self.btn_system_toggle.connect("clicked", self.on_system_service_toggle)
        self.switch_system_enable = Gtk.Switch()
        self.switch_system_enable.connect("notify::active", self.on_system_enable_toggle)
        vbox_services.pack_start(self.create_service_row(_("Syst√©mov√° slu≈æba (Init)"), self.status_system, self.btn_system_toggle, self.switch_system_enable), False, False, 0)

        # 2. Sekce: U≈æivatelsk√° konfigurace
        frame_user = Gtk.Frame(label=_("U≈æivatelsk√° konfigurace"))
        self.page_general.pack_start(frame_user, False, False, 0)
        vbox_user = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        vbox_user.set_border_width(10)
        frame_user.add(vbox_user)

        lbl_info_user = Gtk.Label(label=_("<i>Ukl√°d√° se do ~/.config/asus-screen-toggle/config.conf</i>"), use_markup=True, xalign=0)
        vbox_user.pack_start(lbl_info_user, False, False, 5)

        self.user_chk_dbus = Gtk.CheckButton(label=_("Povolit D-Bus ovl√°d√°n√≠ (ENABLE_DBUS)"))
        self.user_chk_signal = Gtk.CheckButton(label=_("Povolit reakci na sign√°ly/rotaci (ENABLE_SIGNAL)"))

        vbox_user.pack_start(self.user_chk_dbus, False, False, 0)
        vbox_user.pack_start(self.user_chk_signal, False, False, 0)


        # --- KARTA 2: HARDWARE (Syst√©mov√° konfigurace) ---
        self.page_hw = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.page_hw.set_border_width(10)
        self.notebook.append_page(self.page_hw, Gtk.Label(label=_("Hardware (Syst√©m)")))

        lbl_hw_info = Gtk.Label(label=_("<i>Tyto zmƒõny se zap√≠≈°√≠ do /etc/asus-screen-toggle.conf (vy≈æaduje root).</i>"), use_markup=True, xalign=0)
        self.page_hw.pack_start(lbl_hw_info, False, False, 0)

        # Checkbox pro syst√©mov√© chov√°n√≠
        self.sys_chk_systemd = Gtk.CheckButton(label=_("Povolit Systemd ovl√°d√°n√≠ (ENABLE_SYSTEMD_CALL)"))
        self.sys_chk_dbus = Gtk.CheckButton(label=_("Povolit D-Bus ovl√°d√°n√≠ (ENABLE_DBUS)"))
        self.sys_chk_signal = Gtk.CheckButton(label=_("Povolit reakci na sign√°ly/rotaci (ENABLE_SIGNAL)"))
        self.sys_chk_direct = Gtk.CheckButton(label=_("Povolit p≈ô√≠m√© vol√°n√≠ z Udev (ENABLE_DIRECT_CALL)"))
        self.page_hw.pack_start(self.sys_chk_dbus, False, False, 0)
        self.page_hw.pack_start(self.sys_chk_signal, False, False, 0)
        self.page_hw.pack_start(self.sys_chk_direct, False, False, 0)
        self.page_hw.pack_start(self.sys_chk_systemd, False, False, 0)
        self.page_hw.pack_start(Gtk.Separator(), False, False, 5)

        grid_hw = Gtk.Grid()
        grid_hw.set_column_spacing(10)
        grid_hw.set_row_spacing(10)
        self.page_hw.pack_start(grid_hw, False, False, 0)

        # Vytvo≈ôen√≠ vstupn√≠ch pol√≠
        self.entry_vendor = Gtk.Entry()
        self.entry_product = Gtk.Entry()
        self.entry_primary = Gtk.Entry()
        self.entry_secondary = Gtk.Entry()
        self.entry_lid = Gtk.Entry()

        row = 0
        self.add_config_row(grid_hw, row, _("Vendor ID:"), self.entry_vendor, _("Nap≈ô. 0b05")); row+=1
        self.add_config_row(grid_hw, row, _("Product ID:"), self.entry_product, _("Nap≈ô. 1bf2")); row+=1
        self.add_config_row(grid_hw, row, _("Hlavn√≠ displej:"), self.entry_primary, _("Nap≈ô. eDP-1")); row+=1
        self.add_config_row(grid_hw, row, _("Sekund√°rn√≠ displej:"), self.entry_secondary, _("Nap≈ô. eDP-2")); row+=1
        self.add_config_row(grid_hw, row, _("Senzor v√≠ka:"), self.entry_lid, _("Nap≈ô. LID nebo LID0")); row+=1

        # Propojen√≠ checkbox≈Ø pro okam≈æitou odezvu v UI
        self.sys_chk_dbus.connect("toggled", lambda w: self.user_chk_dbus.set_sensitive(w.get_active()))
        self.sys_chk_signal.connect("toggled", lambda w: self.user_chk_signal.set_sensitive(w.get_active()))

        # --- Spodn√≠ li≈°ta tlaƒç√≠tek ---
        bbox = Gtk.ButtonBox(layout_style=Gtk.ButtonBoxStyle.END)
        main_layout.pack_end(bbox, False, False, 0)

        btn_refresh = Gtk.Button(label=_("Obnovit"))
        btn_refresh.connect("clicked", self.refresh_all)
        bbox.add(btn_refresh)

        btn_save = Gtk.Button(label=_("Ulo≈æit v≈°e"))
        btn_save.get_style_context().add_class("suggested-action")
        btn_save.connect("clicked", self.on_save_clicked)
        bbox.add(btn_save)

        # Start
        self.current_mode_in_ui = None # Pro sledov√°n√≠ stavu UI
        self.refresh_all()
        GLib.timeout_add_seconds(3, self.refresh_services_only)

    # --- UI Helpers pro Domovskou str√°nku ---

    def create_mode_button(self, title, icon_path, subtitle, mode_id):
        """Vytvo≈ô√≠ velk√© tlaƒç√≠tko s ikonou pro v√Ωbƒõr re≈æimu."""
        btn = Gtk.Button()
        btn.set_relief(Gtk.ReliefStyle.NORMAL)
        btn.set_size_request(140, 160) # Pevn√° velikost

        # Obsah tlaƒç√≠tka (Vertical Box)
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        vbox.set_valign(Gtk.Align.CENTER)

        # Ikona
        try:
            pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_scale(icon_path, 64, 64, True)
            img = Gtk.Image.new_from_pixbuf(pixbuf)
        except:
            img = Gtk.Image.new_from_icon_name("image-missing", Gtk.IconSize.DIALOG)

        vbox.pack_start(img, True, True, 5)

        # Texty
        lbl_title = Gtk.Label(label=f"<b>{title}</b>")
        lbl_title.set_use_markup(True)
        vbox.pack_start(lbl_title, False, False, 0)

        lbl_sub = Gtk.Label(label=f"<small>{subtitle}</small>")
        lbl_sub.set_use_markup(True)
        lbl_sub.get_style_context().add_class("dim-label")
        vbox.pack_start(lbl_sub, False, False, 0)

        btn.add(vbox)

        # Ulo≈æ√≠me ID re≈æimu do tlaƒç√≠tka pro callback
        btn.mode_id = mode_id
        btn.connect("clicked", self.on_mode_clicked)

        return btn

    def update_home_ui_state(self, current_mode):
        """Zv√Ωrazn√≠ aktivn√≠ tlaƒç√≠tko podle re≈æimu."""
        self.current_mode_in_ui = current_mode

        # Reset styl≈Ø (pomoc√≠ citlivosti - aktivn√≠ re≈æim bude 'insensitive', tedy zam√°ƒçknut√Ω)
        # Nebo l√©pe: V≈°echny sensitive, ale aktivn√≠mu d√°me jin√Ω styl nebo relief.
        # Zde pou≈æijeme logiku: Aktivn√≠ tlaƒç√≠tko je "deaktivovan√©" (nejde na nƒõj znovu kliknout) a vypad√° zam√°ƒçkle.

        for btn, mid in [(self.btn_mode_auto, "automatic-enabled"),
                         (self.btn_mode_primary, "enforce-primary-only"),
                         (self.btn_mode_desktop, "enforce-desktop")]:
            if mid == current_mode:
                btn.set_sensitive(False) # Vizu√°lnƒõ indikuje "vybr√°no"
                # btn.get_style_context().add_class("suggested-action") # Alternativa pro GTK CSS
            else:
                btn.set_sensitive(True)

    def on_mode_clicked(self, btn):
        mode = btn.mode_id
        print(_(f"UI: Po≈æadavek na zmƒõnu re≈æimu -> {mode}"))

        success = False

        # 1. Zkusit D-Bus (synchronizace s Agentem)
        if DBUS_AVAILABLE:
            try:
                bus = SessionBus()
                # Z√≠sk√°me proxy objekt
                agent_proxy = bus.get(BUS_NAME) # Z√≠sk√° hlavn√≠ object path
                # Vol√°me metodu SetMode
                resp = agent_proxy.SetMode(mode)
                print(_(f"D-Bus odpovƒõƒè: {resp}"))
                success = True
            except Exception as e:
                print(_(f"D-Bus chyba (Agent nebƒõ≈æ√≠?): {e}"))

        # 2. Fallback: Z√°pis do souboru (pokud D-Bus selhal)
        if not success:
            print(_("Fallback: Zapisuji p≈ô√≠mo do souboru..."))
            try:
                os.makedirs(STATE_DIR, exist_ok=True)
                with open(STATE_FILE, 'w') as f:
                    f.write(mode)
                self.run_check() # Spust√≠me script manu√°lnƒõ
            except Exception as e:
                self.show_error(_(f"Nepoda≈ôilo se zapsat stav: {e}"))
                return

        # UI aktualizujeme hned pro odezvu (timer to pak potvrd√≠)
        self.update_home_ui_state(mode)

    def run_check(self):
        try:
            subprocess.Popen([SCRIPT_PATH])
        except Exception as e:
            self.show_error(_(f"Chyba p≈ôi spou≈°tƒõn√≠ skriptu: {e}"))

    def periodic_refresh(self):
        self.refresh_all()
        return True # Pokraƒçovat v timeru

    def refresh_all(self, widget=None):
        # 1. Re≈æim (ƒçten√≠ ze souboru - synchronizace od Agenta k Aplikaci)
        if os.path.exists(STATE_FILE):
            try:
                with open(STATE_FILE, 'r') as f:
                    mode = f.read().strip()
                    if mode != self.current_mode_in_ui:
                        self.update_home_ui_state(mode)
            except: pass

        # 2. Configy
        self.load_configs()
        # 3. Slu≈æby
        self.refresh_services_only()

    # ... (Zbytek k√≥du: create_service_row, load_configs, on_save_clicked atd. z≈Øst√°v√° stejn√Ω) ...

    # Pro √∫plnost kop√≠ruji zkr√°cenƒõ zbytek metod, aby soubor byl kompletn√≠:

    def create_service_row(self, title, label_status, btn_toggle, switch_enable):
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        lbl = Gtk.Label(label=title, xalign=0)
        lbl.set_size_request(200, -1)
        row.pack_start(lbl, False, False, 0)
        row.pack_start(label_status, True, True, 0)
        row.pack_start(btn_toggle, False, False, 0)
        row.pack_start(Gtk.Label(label=_("Boot:")), False, False, 0)
        row.pack_start(switch_enable, False, False, 0)
        return row

    def add_config_row(self, grid, row, label_text, entry_widget, placeholder):
        lbl = Gtk.Label(label=label_text, xalign=1)
        entry_widget.set_placeholder_text(placeholder)
        entry_widget.set_hexpand(True)
        grid.attach(lbl, 0, row, 1, 1)
        grid.attach(entry_widget, 1, row, 1, 1)

    def refresh_services_only(self):
        active, enabled = self.get_service_status(USER_SERVICE, user=True)
        self.update_service_ui(self.status_user, self.btn_user_toggle, self.switch_user_enable, active, enabled)

        active, enabled = self.get_service_status(SYSTRAY_SERVICE, user=True)
        self.update_service_ui(self.status_systray, self.btn_systray_toggle, self.switch_systray_enable, active, enabled)

        active, enabled = self.get_service_status(SYSTEM_SERVICE, user=False)
        self.update_service_ui(self.status_system, self.btn_system_toggle, self.switch_system_enable, active, enabled)
        return True

    def get_service_status(self, service, user=True):
        cmd = ["systemctl"]
        if user: cmd.append("--user")

        res_act = subprocess.run(cmd + ["is-active", service], stdout=subprocess.PIPE, text=True)
        res_en = subprocess.run(cmd + ["is-enabled", service], stdout=subprocess.PIPE, text=True)
        return (res_act.stdout.strip() == _("active"), res_en.stdout.strip() == _("enabled"))

    def update_service_ui(self, label, button, switch, active, enabled):
        switch.handler_block_by_func(self.on_user_enable_toggle if switch == self.switch_user_enable else self.on_system_enable_toggle if switch == self.switch_system_enable else self.on_systray_enable_toggle)
        switch.set_active(enabled)
        switch.handler_unblock_by_func(self.on_user_enable_toggle if switch == self.switch_user_enable else self.on_system_enable_toggle if switch == self.switch_system_enable else self.on_systray_enable_toggle)

        if active:
            label.set_markup(_("<span foreground='green'><b>Bƒõ≈æ√≠</b></span>"))
            button.set_label(_("Zastavit"))
        else:
            label.set_markup(_("<span foreground='red'>Zastaveno</span>"))
            button.set_label(_("Spustit"))

    def load_configs(self):
        # 1. Naƒç√≠st SYST√âMOV√â nastaven√≠ (defaulty + /etc)
        sys_data = {
            "VENDOR_ID": "0b05", "PRODUCT_ID": "1bf2",
            "PRIMARY_DISPLAY_NAME": "eDP-1", "SECONDARY_DISPLAY_NAME": "eDP-2",
            "LID": "LID",
            "ENABLE_DIRECT_CALL": True,
            "ENABLE_DBUS": True, "ENABLE_SIGNAL": True, "ENABLE_SYSTEMD_CALL": True
        }

        if os.path.exists(SYSTEM_CONFIG_FILE):
            sys_data.update(self._parse_config_file(SYSTEM_CONFIG_FILE))

        # Aplikace do GUI - Hardware a Syst√©m
        self.entry_vendor.set_text(str(sys_data.get("VENDOR_ID", "")))
        self.entry_product.set_text(str(sys_data.get("PRODUCT_ID", "")))
        self.entry_primary.set_text(str(sys_data.get("PRIMARY_DISPLAY_NAME", "")))
        self.entry_secondary.set_text(str(sys_data.get("SECONDARY_DISPLAY_NAME", "")))
        self.entry_lid.set_text(str(sys_data.get("LID", "")))

        # Syst√©mov√© checkboxy
        sys_dbus_active = sys_data.get("ENABLE_DBUS") is True
        sys_signal_active = sys_data.get("ENABLE_SIGNAL") is True
        sys_systemd_active = sys_data.get("ENABLE_SYSTEMD_CALL") is True

        self.sys_chk_direct.set_active(sys_data.get("ENABLE_DIRECT_CALL") is True)
        self.sys_chk_dbus.set_active(sys_dbus_active)
        self.sys_chk_signal.set_active(sys_signal_active)
        self.sys_chk_systemd.set_active(sys_systemd_active)

        # 2. Naƒç√≠st U≈ΩIVATELSK√â nastaven√≠
        user_data = {}
        if os.path.exists(USER_CONFIG_FILE):
            user_data = self._parse_config_file(USER_CONFIG_FILE)

        # Logika AND detekovan√° p≈ô√≠mo v UI:
        # Pokud je SYST√âM False, u≈æivatel nesm√≠ zapnout.

        # DBUS
        user_dbus_val = user_data.get("ENABLE_DBUS", sys_dbus_active)
        self.user_chk_dbus.set_active(user_dbus_val and sys_dbus_active)
        self.user_chk_dbus.set_sensitive(sys_dbus_active) # Za≈°edne, pokud syst√©m zak√°zal

        # SIGNAL
        user_signal_val = user_data.get("ENABLE_SIGNAL", sys_signal_active)
        self.user_chk_signal.set_active(user_signal_val and sys_signal_active)
        self.user_chk_signal.set_sensitive(sys_signal_active) # Za≈°edne, pokud syst√©m zak√°zal

        # Bonus: tooltip pro vysvƒõtlen√≠
        if not sys_signal_active:
            self.user_chk_signal.set_tooltip_text(_("Zak√°z√°no spr√°vcem v /etc/asus-screen-toggle.conf"))


    def _parse_config_file(self, filepath):
        data = {}
        try:
            with open(filepath, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#") or "=" not in line: continue
                    key, val = line.split("=", 1)
                    key = key.strip()
                    val = val.strip().replace('"', '')

                    if val.lower() == "true": data[key] = True
                    elif val.lower() == "false": data[key] = False
                    else: data[key] = val
        except: pass
        return data

    # --- Logika ukl√°d√°n√≠ ---
    def on_save_clicked(self, widget):
        # 1. ULO≈ΩEN√ç U≈ΩIVATELSK√âHO CONFIGU (~/.config)
        # Zde ukl√°d√°me POUZE preference chov√°n√≠
        try:
            os.makedirs(os.path.dirname(USER_CONFIG_FILE), exist_ok=True)
            with open(USER_CONFIG_FILE, 'w') as f:
                f.write(_("# U≈æivatelsk√° konfigurace Asus Screen Toggle\n"))
                f.write(f"ENABLE_DBUS={'true' if self.user_chk_dbus.get_active() else 'false'}\n")
                f.write(f"ENABLE_SIGNAL={'true' if self.user_chk_signal.get_active() else 'false'}\n")
        except Exception as e:
            self.show_error(_(f"Nepoda≈ôilo se ulo≈æit u≈æivatelsk√Ω config: {e}"))
            return

        # 2. ULO≈ΩEN√ç SYST√âMOV√âHO CONFIGU (/etc)
        # Zde ukl√°d√°me Hardware a Direct Call
        sys_content = [
            _("# Vygenerov√°no Asus Screen Settings - Syst√©mov√° konfigurace"),
            f'VENDOR_ID="{self.entry_vendor.get_text()}"',
            f'PRODUCT_ID="{self.entry_product.get_text()}"',
            f'PRIMARY_DISPLAY_NAME="{self.entry_primary.get_text()}"',
            f'SECONDARY_DISPLAY_NAME="{self.entry_secondary.get_text()}"',
            f'LID="{self.entry_lid.get_text()}"',
            "",
            f'ENABLE_DIRECT_CALL={"true" if self.sys_chk_direct.get_active() else "false"}',
            f'ENABLE_DBUS={"true" if self.sys_chk_dbus.get_active() else "false"}',
            f'ENABLE_SIGNAL={"true" if self.sys_chk_signal.get_active() else "false"}',
            f'ENABLE_SYSTEMD_CALL={"true" if self.sys_chk_systemd.get_active() else "false"}',
        ]

        file_content = "\n".join(sys_content)

        # Ulo≈æen√≠ p≈ôes pkexec
        cmd = f"cat <<EOF > /tmp/asus_conf_tmp\n{file_content}\nEOF\n"
        cmd += f"pkexec mv /tmp/asus_conf_tmp {SYSTEM_CONFIG_FILE}"

        try:
            # A) Samotn√© ulo≈æen√≠ souboru
            subprocess.run(["bash", "-c", cmd], check=True)

            # B) Dotaz na p≈ôegenerov√°n√≠ pravidel (pouze pokud se ulo≈æen√≠ povedlo)
            confirm = Gtk.MessageDialog(transient_for=self, flags=0,
                                      message_type=Gtk.MessageType.QUESTION,
                                      buttons=Gtk.ButtonsType.YES_NO,
                                      text=_("Aktualizovat Udev pravidla?"))
            confirm.format_secondary_text(
                _("Zmƒõnili jste syst√©mov√© nastaven√≠. Pro spr√°vnou funkƒçnost detekce hardwaru "
                "je t≈ôeba p≈ôegenerovat a naƒç√≠st pravidla Udev.\n\n"
                "Chcete to prov√©st nyn√≠? (Vy≈æaduje heslo)")
            )
            response = confirm.run()
            confirm.destroy()

            if response == Gtk.ResponseType.YES:
                try:
                    # Sestav√≠me ≈ôetƒõzec p≈ô√≠kaz≈Ø:
                    # 1. Spustit generovac√≠ skript
                    # 2. Reloadnout pravidla (pokud 1. pro≈°la)
                    # 3. Triggerovat ud√°losti (pokud 2. pro≈°la)
                    full_cmd = (
                        "&GENRULES_PATH && "
                        "udevadm control --reload-rules && "
                        "udevadm trigger"
                    )

                    # Spust√≠me v≈°e pod jedn√≠m pkexec (jedno heslo)
                    subprocess.run(["pkexec", "bash", "-c", full_cmd], check=True)

                except subprocess.CalledProcessError:
                     self.show_error(_("Nepoda≈ôilo se p≈ôegenerovat a aplikovat pravidla."))

            # C) Restart agenta (aby naƒçetl p≈ô√≠padn√© zmƒõny v logice)
            subprocess.run(["systemctl", "--user", "kill", "-s", "HUP", USER_SERVICE])

            # Fin√°ln√≠ info
            msg = Gtk.MessageDialog(transient_for=self, flags=0, message_type=Gtk.MessageType.INFO,
                                  buttons=Gtk.ButtonsType.OK, text=_("Hotovo"))
            msg.format_secondary_text(_("Konfigurace byla √∫spƒõ≈°nƒõ ulo≈æena."))
            msg.run()
            msg.destroy()

        except subprocess.CalledProcessError:
            self.show_error(_("Nepoda≈ôilo se ulo≈æit syst√©movou konfiguraci (zam√≠tnuto)."))

    # --- Handlery Slu≈æeb ---
    def on_user_service_toggle(self, btn):
        action = "stop" if btn.get_label() == _("Zastavit") else "start"
        subprocess.run(["systemctl", "--user", action, USER_SERVICE])
        self.refresh_services_only()

    def on_systray_service_toggle(self, btn):
        action = "stop" if btn.get_label() == _("Zastavit") else "start"
        subprocess.run(["systemctl", "--user", action, SYSTRAY_SERVICE])
        self.refresh_services_only()

    def on_user_enable_toggle(self, switch, gparam):
        action = "enable" if switch.get_active() else "disable"
        subprocess.run(["systemctl", "--user", action, USER_SERVICE])
        self.refresh_services_only()

    def on_systray_enable_toggle(self, switch, gparam):
        action = "enable" if switch.get_active() else "disable"
        subprocess.run(["systemctl", "--user", action, SYSTRAY_SERVICE])
        self.refresh_services_only()

    def on_system_service_toggle(self, btn):
        action = "stop" if btn.get_label() == "Zastavit" else "start"
        subprocess.run(["pkexec", "systemctl", action, SYSTEM_SERVICE])
        self.refresh_services_only()

    def on_system_enable_toggle(self, switch, gparam):
        action = "enable" if switch.get_active() else "disable"
        subprocess.run(["pkexec", "systemctl", action, SYSTEM_SERVICE])
        self.refresh_services_only()

    def show_error(self, message):
        dialog = Gtk.MessageDialog(transient_for=self, flags=0, message_type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK, text=_("Chyba"))
        dialog.format_secondary_text(message)
        dialog.run()
        dialog.destroy()

if __name__ == "__main__":
    app = AsusSettingsApp()
    app.connect("destroy", Gtk.main_quit)
    app.show_all()
    Gtk.main()


================================================================================

üìÑ PATH: asus-screen-toggle/usr/bin/asus-check-keyboard-genrules.sh
--------------------------------------------------------------------------------
#!/bin/bash

source /etc/asus-screen-toggle.conf

export VENDOR_ID PRODUCT_ID PRIMARY_DISPLAY_NAME SECONDARY_DISPLAY_NAME LID

echo "vid $VENDOR_ID"
echo "pid $PRODUCT_ID"
echo "pd $PRIMARY_DISPLAY_NAME"
echo "sd $SECONDARY_DISPLAY_NAME"
echo "lid $LID"

#envsubst < /usr/share/asus-screen-toggle/99-asus-keyboard.rules.template > /usr/lib/udev/rules.d/99-asus-keyboard.rules
envsubst < /usr/share/asus-screen-toggle/99-asus-keyboard.rules.template > /etc/udev/rules.d/99-asus-keyboard.rules



================================================================================

üìÑ PATH: asus-screen-toggle/usr/bin/asus-check-keyboard-user.sh
--------------------------------------------------------------------------------
#!/bin/bash

export TEXTDOMAIN="asus-screen-toggle"
export TEXTDOMAINDIR="/usr/share/locale"

# Funkce pro zjednodu≈°en√≠ (alias)
function _() {
    gettext "$1"
}

# --- 1. Naƒçten√≠ konfigurace ---
if [[ -f /etc/asus-screen-toggle.conf ]]; then
    source /etc/asus-screen-toggle.conf
else
    # Pokud konfig neexistuje, nastav√≠me defaulty, aby skript nespadl
    VENDOR_ID="0b05"
    PRODUCT_ID="1bf2"
    PRIMARY_DISPLAY_NAME="eDP-1"
    SECONDARY_DISPLAY_NAME="eDP-2"
fi

# Pokud m√°me rotaci z monitor-sensor (ulo≈æenou v tmp), naƒçteme ji
if [[ -f /tmp/asus-rotation ]]; then
    source /tmp/asus-rotation
else
    # Fallback, pokud neexistuje temp soubor (nap≈ô. ruƒçn√≠ spu≈°tƒõn√≠)
    # timeout zajist√≠, ≈æe se nezasekne, pokud senzor nen√≠ dostupn√Ω
    DIR=$(timeout 0.5 monitor-sensor --accel | grep -m 1 orientation)
fi

# --- 2. Zji≈°tƒõn√≠ po≈æadavku u≈æivatele (State) ---
APP_NAME="asus-check-keyboard"
STATE_FILE="$HOME/.local/state/$APP_NAME/state"
USER_STATE="automatic-enabled"

if [[ -f "$STATE_FILE" ]]; then
    USER_STATE=$(<"$STATE_FILE")
fi

printf "$(_ "VID: %s, PID: %s")\n" "$VENDOR_ID" "$PRODUCT_ID"
printf "$(_ "User mode: %s")\n" "$USER_STATE"
printf "$(_ "Sensor: %s")\n" "$DIR"

# --- 3. Rozhodovac√≠ logika (Matrix) ---

# A) Je fyzicky p≈ôipojen√° kl√°vesnice?
PHYSICAL_KEYBOARD_CONNECTED=false
if lsusb | grep -iq "${VENDOR_ID}:${PRODUCT_ID}"; then
    PHYSICAL_KEYBOARD_CONNECTED=true
    echo "$(_ "Fyzick√° kl√°vesnice: P≈òIPOJENA")"
else
    echo "$(_ "Fyzick√° kl√°vesnice: ODPOJENA")"
fi

# B) V√Ωpoƒçet fin√°ln√≠ho stavu spodn√≠ho displeje
# Defaultnƒõ (Auto) plat√≠: Kl√°vesnice je p≈ôipojen√° => Vypnout spodek.
ENABLE_BOTTOM_SCREEN=true
if [[ "$PHYSICAL_KEYBOARD_CONNECTED" == "true" ]]; then
    ENABLE_BOTTOM_SCREEN=false
fi

# C) Aplikace vynucen√Ωch re≈æim≈Ø (Overrides)
case "$USER_STATE" in
    enforce-primary-only)
        echo "$(_ "Vynuceno: Jen prim√°rn√≠ displej")"
        ENABLE_BOTTOM_SCREEN=false
        ;;
    enforce-desktop)
        echo "$(_ "Vynuceno: Desktop m√≥d (oba displeje)")"
        ENABLE_BOTTOM_SCREEN=true
        ;;
    *)
        echo "$(_ "Re≈æim Auto: Ponech√°v√°m vypoƒçten√Ω stav.")"
        ;;
esac


# --- 4. P≈ô√≠prava promƒõnn√Ωch pro rotaci (KDE/X11) ---
# Ponech√°me logiku pro DISPLAY_ROTATION beze zmƒõny, jen ji sem zkop√≠rujte
# nebo nechte, pokud editujete soubor. Zde pro √∫plnost:

DISPLAY_ROTATION="normal"
case "$DIR" in
*normal*)    DISPLAY_ROTATION="normal"   ;;
*bottom-up*) DISPLAY_ROTATION="inverted" ;;
*left-up*)   DISPLAY_ROTATION="left"     ;;
*right-up*)  DISPLAY_ROTATION="right"    ;;
esac

# --- 5. Aplikace nastaven√≠ (X11 / KDE / Wayland) ---

user=$USER
type=$XDG_SESSION_TYPE
desktop_env=$XDG_CURRENT_DESKTOP

if [[ "$user" == "sddm" ]]; then exit 0; fi

# === X11 ===
if [[ "$type" == "x11" ]]; then
    # Zde pou≈æ√≠v√°me na≈°i vypoƒçtenou promƒõnnou ENABLE_BOTTOM_SCREEN
    if [[ "$ENABLE_BOTTOM_SCREEN" == "false" ]]; then
        echo "$(_ "Aplikuji: Single Screen (X11)")"
        xrandr --output ${PRIMARY_DISPLAY_NAME} --rotate normal --output ${SECONDARY_DISPLAY_NAME} --off
    else
        printf "$(_ "Aplikuji: Dual Screen (X11) - %s")\n" "$DISPLAY_ROTATION"
        case "$DISPLAY_ROTATION" in
            *left*) xrandr --output ${PRIMARY_DISPLAY_NAME} --rotate ${DISPLAY_ROTATION} --right-of ${SECONDARY_DISPLAY_NAME} --output ${SECONDARY_DISPLAY_NAME} --auto --rotate ${DISPLAY_ROTATION} ;;
            *right*) xrandr --output ${PRIMARY_DISPLAY_NAME} --rotate ${DISPLAY_ROTATION} --left-of ${SECONDARY_DISPLAY_NAME} --output ${SECONDARY_DISPLAY_NAME} --auto --rotate ${DISPLAY_ROTATION} ;;
            *inverted*) xrandr --output ${PRIMARY_DISPLAY_NAME} --rotate ${DISPLAY_ROTATION} --below ${SECONDARY_DISPLAY_NAME} --output ${SECONDARY_DISPLAY_NAME} --auto --rotate ${DISPLAY_ROTATION} ;;
            *normal*) xrandr --output ${PRIMARY_DISPLAY_NAME} --rotate ${DISPLAY_ROTATION} --above ${SECONDARY_DISPLAY_NAME} --output ${SECONDARY_DISPLAY_NAME} --auto --rotate ${DISPLAY_ROTATION} ;;
        esac
    fi
    exit 0
fi

# === Wayland (KDE) ===
if [[ "$type" == "wayland" && "$desktop_env" == "KDE" ]]; then
    if [[ "$ENABLE_BOTTOM_SCREEN" == "false" ]]; then
        printf "%s\n" "$(_ "Aplikuji: Single Screen (KDE)")"
        /usr/bin/kscreen-doctor output.${PRIMARY_DISPLAY_NAME}.rotation.normal
        /usr/bin/kscreen-doctor output.${SECONDARY_DISPLAY_NAME}.disable
    else
        printf "$(_ "Aplikuji: Dual Screen (KDE) - %s")\n" "$DISPLAY_ROTATION"
        /usr/bin/kscreen-doctor output.${PRIMARY_DISPLAY_NAME}.rotation.${DISPLAY_ROTATION}
        /usr/bin/kscreen-doctor output.${SECONDARY_DISPLAY_NAME}.enable output.${SECONDARY_DISPLAY_NAME}.rotation.${DISPLAY_ROTATION}

        # --- Z√≠sk√°n√≠ geometrie prim√°rn√≠ho v√Ωstupu ---
        read PX PY PW PH <<< $(kscreen-doctor -o | awk -v out="$PRIMARY_DISPLAY_NAME" '$0 ~ "Output: " && $0 ~ out { in_block=1; next } in_block && $0 ~ "Geometry:" { split($3, pos, ","); split($4, res, "x"); print pos[1], pos[2], res[1], res[2]; exit }')
        echo "$PRIMARY_DISPLAY_NAME $PX,$PY,$PW,$PH"

        # --- Z√≠sk√°n√≠ velikosti sekund√°rn√≠ho v√Ωstupu ---
        read SX SY SW SH <<< $(kscreen-doctor -o | awk -v out="$SECONDARY_DISPLAY_NAME" '$0 ~ "Output: " && $0 ~ out { in_block=1; next } in_block && $0 ~ "Geometry:" { split($3, pos, ","); split($4, res, "x"); print pos[1], pos[2], res[1], res[2]; exit }')
        echo "$SECONDARY_DISPLAY_NAME $SX,$SY,$SW,$SH"

        PX=0
        PY=0

        # --- V√Ωpoƒçet nov√© pozice ---
        case "$DISPLAY_ROTATION" in
            *left*)
                PX=$(echo "$PX" | tr -dc '0-9')
                SW=$(echo "$SW" | tr -dc '0-9')
                SX=$((PX - SW))
                SY=$PY
                ;;
            *right*)
                PX=$(echo "$PX" | tr -dc '0-9')
                PW=$(echo "$PW" | tr -dc '0-9')
                SX=$((PX + PW))
                SY=$PY
                ;;
            *inverted*)
                SX=$PX
                SY=$((PY - SH))
                ;;
            *normal*)
                SX=$PX
                SY=$((PY + PH))
                ;;
            *)
                printf "$(_ "Neplatn√° orientace: %s")\n" "$DISPLAY_ROTATION"
                exit 1
                ;;
        esac

        echo "$PRIMARY_DISPLAY_NAME $PX,$PY,$PW,$PH"
        echo "$SECONDARY_DISPLAY_NAME $SX,$SY,$SW,$SH"

        # --- V√Ωstup a nastaven√≠ ---
        printf "$(_ "Um√≠s≈•uji %s (%s) od %s na sou≈ôadnice %s,%s")\n" "$SECONDARY_DISPLAY_NAME" "$DISPLAY_ROTATION" "$PRIMARY_DISPLAY_NAME" "$SX" "$SY"

        kscreen-doctor output.$PRIMARY_DISPLAY_NAME.position.$PX,$PY output.${PRIMARY_DISPLAY_NAME}.rotation.${DISPLAY_ROTATION}
        kscreen-doctor output.$SECONDARY_DISPLAY_NAME.position.$SX,$SY output.${SECONDARY_DISPLAY_NAME}.rotation.${DISPLAY_ROTATION}

    fi
    exit 0
fi

# === Wayland (Generic / wlroots) ===
if [[ "$type" == "wayland" ]]; then
    if [[ "$ENABLE_BOTTOM_SCREEN" == "false" ]]; then
        echo "$(_ "Aplikuji: Single Screen (Wlr)")"
        wlr-randr --output ${PRIMARY_DISPLAY_NAME} --rotate normal
        wlr-randr --output ${SECONDARY_DISPLAY_NAME} --off
    else
        printf "$(_ "Aplikuji: Dual Screen (Wlr) - %s")\n" "$DISPLAY_ROTATION"
        wlr-randr --output ${SECONDARY_DISPLAY_NAME} --auto --rotate ${DISPLAY_ROTATION}
        case "$DISPLAY_ROTATION" in
            *left*) wlr-randr --output ${PRIMARY_DISPLAY_NAME} --rotate ${DISPLAY_ROTATION} --right-of ${SECONDARY_DISPLAY_NAME} ;;
            *right*) wlr-randr --output ${PRIMARY_DISPLAY_NAME} --rotate ${DISPLAY_ROTATION} --left-of ${SECONDARY_DISPLAY_NAME} ;;
            *inverted*) wlr-randr --output ${PRIMARY_DISPLAY_NAME} --rotate ${DISPLAY_ROTATION} --below ${SECONDARY_DISPLAY_NAME} ;;
            *normal*) wlr-randr --output ${PRIMARY_DISPLAY_NAME} --rotate ${DISPLAY_ROTATION} --above ${SECONDARY_DISPLAY_NAME} ;;
        esac
    fi
    exit 0
fi


================================================================================

üìÑ PATH: asus-screen-toggle/usr/bin/asus-screen-toggle-launcher.sh
--------------------------------------------------------------------------------
#!/bin/bash
set -e

# Seznam slu≈æeb: worker (oneshot) a agent (systray)
SERVICES=("asus-screen-toggle.service" "asus-user-agent.service")

echo "‚ñ∂Ô∏è Asus Screen Toggle ‚Äì launcher"

# Kontrola, aby nebƒõ≈æelo pod rootem (u≈æivatelsk√© slu≈æby spravuje u≈æivatel)
if [[ $EUID -eq 0 ]]; then
    echo "‚ùå Tento launcher nesm√≠ bƒõ≈æet jako root."
    exit 1
fi

# 1Ô∏è‚É£ Obnoven√≠ konfigurace systemd (naƒçte zmƒõny v .service souborech)
systemctl --user daemon-reload

# 2Ô∏è‚É£ Aktivace a spu≈°tƒõn√≠ obou komponent
for SERVICE in "${SERVICES[@]}"; do
    echo "--- Spr√°va jednotky: $SERVICE ---"

    # Povolen√≠ slu≈æby (aby se spou≈°tƒõla automaticky p≈ôi startu graphical-session)
    if ! systemctl --user is-enabled --quiet "$SERVICE"; then
        echo "üîî Povoluji $SERVICE"
        systemctl --user enable "$SERVICE"
    else
        echo "‚úÖ $SERVICE je povolena"
    fi

    # Spu≈°tƒõn√≠ slu≈æby
    # U oneshotu (worker) to provede nastaven√≠, u simple (agent) to spust√≠ tray ikonu
    echo "‚ñ∂Ô∏è Spou≈°t√≠m/Restartuji $SERVICE"
    systemctl --user restart "$SERVICE"
done

echo "üéâ Hotovo ‚Äì nastaven√≠ aplikov√°no a agent bƒõ≈æ√≠."


================================================================================

üìÑ PATH: asus-screen-toggle/usr/bin/asus-user-agent.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
import sys
import os
import signal
import subprocess
import warnings
import time # Nov√Ω import pro ƒças
import gettext
import locale

# Nastaven√≠ lokalizace
APP_NAME = "asus-screen-toggle"
LOCALE_DIR = "/usr/share/locale"

try:
    # Pokus√≠me se nastavit syst√©movou locale
    locale.setlocale(locale.LC_ALL, '')

    # Inicializace gettext
    gettext.bindtextdomain(APP_NAME, LOCALE_DIR)
    gettext.textdomain(APP_NAME)
    _ = gettext.gettext
except Exception as e:
    # Fallback, pokud gettext sel≈æe (nap≈ô. p≈ôi v√Ωvoji mimo instalaci)
    print(f"Warning: Localization not loaded: {e}")
    _ = lambda s: s

warnings.filterwarnings("ignore")
from pydbus.generic import signal as Signal

# --- Importy knihoven ---
print(_("DEBUG: Naƒç√≠t√°m knihovny..."))
try:
    import gi
    try:
        gi.require_version('AyatanaAppIndicator3', '0.1')
        from gi.repository import AyatanaAppIndicator3 as AppIndicator
    except (ValueError, ImportError):
        try:
            gi.require_version('AppIndicator3', '0.1')
            from gi.repository import AppIndicator3 as AppIndicator
        except (ValueError, ImportError):
            print(_("CHYBA: Nenalezena knihovna AppIndicator."))
            sys.exit(1)

    gi.require_version('Gtk', '3.0')
    from gi.repository import GLib, Gtk
    from pydbus import SessionBus
except Exception as e:
    print(_(f"CHYBA p≈ôi importu knihoven: {e}"))
    sys.exit(1)

# --- Konfigurace ---
BUS_NAME = "org.asus.ScreenToggle"
SCRIPT_PATH = "/usr/bin/asus-check-keyboard-user"
APP_ID = "asus-screen-toggler"
ICON_NAME = "input-tablet"
ICON_PATH = "/usr/share/asus-screen-toggle"

ICON_AUTO_NAME = "icon-green.svg"
ICON_PRIMARY_NAME = "icon-red.svg"
ICON_DESKTOP_NAME = "icon-blue.svg"
ICON_AUTO = os.path.join(ICON_PATH, ICON_AUTO_NAME)
ICON_PRIMARY = os.path.join(ICON_PATH, ICON_PRIMARY_NAME)
ICON_DESKTOP = os.path.join(ICON_PATH, ICON_DESKTOP_NAME)

STATE_DIR = os.path.expanduser("~/.local/state/asus-check-keyboard")
STATE_FILE = os.path.join(STATE_DIR, "state")
CONFIG_FILE = os.path.expanduser("~/.config/asus-screen-toggle/config.conf")

class StatusNotifierItem:
    """
    <node>
      <interface name="org.kde.StatusNotifierItem">
        <property name="Category" type="s" access="read"/>
        <property name="Id" type="s" access="read"/>
        <property name="Title" type="s" access="read"/>
        <property name="Status" type="s" access="read"/>
        <property name="IconName" type="s" access="read"/>
        <property name="IconThemePath" type="s" access="read"/>
        <property name="ItemIsMenu" type="b" access="read"/>
        <property name="ToolTip" type="(sa(iiay)ss)" access="read"/>

        <method name="Activate">
          <arg type="i" direction="in"/>
          <arg type="i" direction="in"/>
        </method>

        <method name="ContextMenu">
          <arg type="i" direction="in"/>
          <arg type="i" direction="in"/>
        </method>

        <method name="SecondaryActivate">
          <arg type="i" direction="in"/>
          <arg type="i" direction="in"/>
        </method>

        <signal name="NewIcon"/>
        <signal name="NewStatus"/>
        <signal name="NewToolTip"/>
      </interface>
    </node>
    """
    NewIcon = Signal()
    NewStatus = Signal()
    NewToolTip = Signal()

    def __init__(self, agent):
        self.agent = agent
        self.icon_name = ICON_AUTO_NAME
        self.status = "Active"

    @property
    def Category(self): return "Hardware"
    @property
    def Id(self): return "asus-screen-toggle"
    @property
    def Title(self): return _("Asus Screen Toggle")
    @property
    def Status(self): return self.status
    @property
    def IconName(self): return self.icon_name
    @property
    def IconThemePath(self): return ICON_PATH
    @property
    def ItemIsMenu(self): return False
    @property
    def Menu(self): return "/StatusNotifierItem"
    @property
    def ToolTip(self): return (self.icon_name, [], _("Asus Screen Toggle"), _(f"Re≈æim: {self.agent.mode}"))

    def Activate(self, x, y):
        """Lev√Ω klik (SNI): Spust√≠ p≈ô√≠mo nastaven√≠."""
        # Vol√°me pomocnou metodu agenta
        GLib.idle_add(self.agent._launch_settings)

    def ContextMenu(self, x, y):
        GLib.idle_add(self.agent._show_gtk_menu, 3)

    def SecondaryActivate(self, x, y):
        self.agent._run_check("SNI_MiddleClick")

    def set_icon(self, name):
        base_name = os.path.splitext(os.path.basename(name))[0]
        if self.icon_name != base_name:
            self.icon_name = base_name
            self.NewIcon()
            self.NewToolTip()

    def set_status(self, status):
        self.status = status
        self.NewStatus()

class AsusAgent:
    """
    <node>
      <interface name="org.asus.ScreenToggle">
        <method name="Trigger"/>
        <method name="SetMode">
          <arg type="s" name="mode" direction="in"/>
        </method>
        <method name="ReloadConfig"/>
        <method name="Quit"/>
      </interface>
    </node>
    """

    def __init__(self, quit_callback, bus):
        self.quit_callback = quit_callback
        self.mode = self._load_mode()
        self.config = self._load_config()
        self.bus = bus
        self.indicator = None
        self.tray_backend = None
        self.menu = None

        # Pro sledov√°n√≠ zmƒõn souboru
        self.last_file_mtime = 0
        if os.path.exists(STATE_FILE):
            self.last_file_mtime = os.stat(STATE_FILE).st_mtime

        if is_kde():
            try:
                self._setup_sni()
            except Exception as e:
                print(f_("SNI failed, fallback na AppIndicator: {e}"))
                self._setup_appindicator()
                self.tray_backend = "appindicator"
        else:
            self._setup_appindicator()
            self.tray_backend = "appindicator"

        # Timer pro sledov√°n√≠ extern√≠ch zmƒõn souboru (ka≈æd√© 2s)
        GLib.timeout_add_seconds(2, self._monitor_file_change)

    # --- Konfigurace ---
    def _load_config(self):
        """
        Naƒçte konfiguraci s prioritou:
        1. Defaultn√≠ hodnoty (v k√≥du)
        2. Syst√©mov√° konfigurace (/etc/asus-screen-toggle.conf)
        3. U≈æivatelsk√° konfigurace (~/.config/asus-screen-toggle/config.conf)
        """
        # 1. Defaultn√≠ hodnoty
        cfg = {"enable_dbus": True, "enable_signal": True}

        # Seznam soubor≈Ø v po≈ôad√≠, jak se maj√≠ aplikovat (posledn√≠ vyhr√°v√°)
        config_paths = [
            "/etc/asus-screen-toggle.conf",
            os.path.expanduser("~/.config/asus-screen-toggle/config.conf")
        ]

        for path in config_paths:
            if os.path.exists(path):
                try:
                    print(_(f"‚öôÔ∏è Naƒç√≠t√°m soubor: {path}"))
                    with open(path, 'r') as f:
                        for line in f:
                            if "=" in line and not line.strip().startswith("#"):
                                key, val = line.strip().split("=", 1)
                                if key.strip().upper() == "ENABLE_DBUS": cfg["enable_dbus"] = (val.strip().lower() == "true")
                                if key.strip().upper() == "ENABLE_SIGNAL": cfg["enable_signal"] = (val.strip().lower() == "true")
                except: pass
        return cfg

    def _monitor_file_change(self):
        """Kontroluje, zda se soubor nezmƒõnil externƒõ (nap≈ô. p≈ôes GUI Settings)."""
        if os.path.exists(STATE_FILE):
            try:
                mtime = os.stat(STATE_FILE).st_mtime
                if mtime != self.last_file_mtime:
                    # Soubor se zmƒõnil!
                    self.last_file_mtime = mtime
                    new_mode = self._load_mode(silent=True)
                    if new_mode != self.mode:
                        print(_(f"üîÑ Detekov√°na extern√≠ zmƒõna stavu -> {new_mode}"))
                        self.mode = new_mode
                        self._set_icon_by_mode()
                        # Zde nespou≈°t√≠me _run_check, proto≈æe p≈ôedpokl√°d√°me,
                        # ≈æe ten kdo soubor zmƒõnil (Settings App), u≈æ skript spustil nebo spust√≠.
                        # Jen aktualizujeme ikonu.
            except: pass
        return True # Pokraƒçovat v timeru

    def _load_mode(self, silent=False):
        if os.path.exists(STATE_FILE):
            try:
                with open(STATE_FILE, 'r') as f:
                    mode = f.read().strip()
                    if mode in ["automatic-enabled", "enforce-primary-only", "enforce-desktop"]:
                        print(_(f"üìÇ Naƒçten re≈æim ze souboru: {mode}"))
                        return mode
            except: pass
        return "automatic-enabled"

    def _save_mode(self, mode):
        try:
            os.makedirs(STATE_DIR, exist_ok=True)
            with open(STATE_FILE, 'w') as f:
                f.write(mode)
            print(_(f"üíæ Re≈æim '{mode}' ulo≈æen do {STATE_FILE}"))
        except Exception as e:
            print(_(f"‚ùå Chyba configu: {e}"))

    # --- D-Bus Metody ---
    def Trigger(self):
        if not self.config["enable_dbus"]: return "DISABLED_BY_CONFIG"
        if self.mode != "automatic-enabled": return f"IGNORED: Mode is {self.mode}"
        self._run_check("D-Bus")
        return "OK"

    def SetMode(self, mode_str):
        if mode_str not in ["automatic-enabled", "enforce-primary-only", "enforce-desktop"]: return "ERROR"
        print(_(f"üì® D-Bus SetMode: {mode_str}"))
        self.mode = mode_str
        self._save_mode(mode_str)
        self._set_icon_by_mode()
        self._run_check("D-Bus_SetMode")
        return _(f"OK: Switched to {mode_str}")

    def Quit(self):
        print("üõë Po≈æadavek na ukonƒçen√≠...")
        self.quit_callback()

    def _launch_settings(self):
        try: subprocess.Popen(["/usr/bin/asus-screen-settings"])
        except: pass
        return False

    def _run_check(self, source="Internal"):
        print(_(f"üöÄ Spou≈°t√≠m logiku ({source})..."))
        try: subprocess.Popen([SCRIPT_PATH])
        except: pass

    def _set_icon_by_mode(self):
        if self.tray_backend == "sni":
            if self.mode == "automatic-enabled": self.sni.set_icon(ICON_AUTO_NAME)
            elif self.mode == "enforce-primary-only": self.sni.set_icon(ICON_PRIMARY_NAME)
            else: self.sni.set_icon(ICON_DESKTOP_NAME)
        elif self.indicator:
            icon_to_set = ICON_NAME
            if self.mode == "automatic-enabled":
                if os.path.exists(ICON_AUTO): icon_to_set = ICON_AUTO
                self.indicator.set_status(AppIndicator.IndicatorStatus.ACTIVE)
            elif self.mode == "enforce-primary-only":
                if os.path.exists(ICON_PRIMARY): icon_to_set = ICON_PRIMARY
                self.indicator.set_status(AppIndicator.IndicatorStatus.ATTENTION)
            else:
                if os.path.exists(ICON_DESKTOP): icon_to_set = ICON_DESKTOP
                self.indicator.set_status(AppIndicator.IndicatorStatus.ATTENTION)
            try: self.indicator.set_icon(icon_to_set)
            except: self.indicator.set_icon(ICON_NAME)

    def _on_mode_change(self, widget, mode_name):
        if widget.get_active():
            self.mode = mode_name
            self._save_mode(mode_name)
            self._set_icon_by_mode()
            self._run_check("MenuChange")

    def _build_menu(self):
        menu = Gtk.Menu()

        item = Gtk.MenuItem(label=_("Asus Screen Control"))
        item.set_sensitive(False)
        menu.append(item)
        menu.append(Gtk.SeparatorMenuItem())

        r_auto = Gtk.RadioMenuItem(label=_("ü§ñ Automaticky"))
        r_auto.connect("toggled", self._on_mode_change, "automatic-enabled")
        menu.append(r_auto)

        group = r_auto.get_group()
        r_prim = Gtk.RadioMenuItem(label=_("üíª Jen hlavn√≠ displej"), group=group[0])
        r_prim.connect("toggled", self._on_mode_change, "enforce-primary-only")
        menu.append(r_prim)

        r_both = Gtk.RadioMenuItem(label=_("üñ•Ô∏èüñ•Ô∏è Oba displeje"), group=group[0])
        r_both.connect("toggled", self._on_mode_change, "enforce-desktop")
        menu.append(r_both)

        if self.mode == "automatic-enabled": r_auto.set_active(True)
        elif self.mode == "enforce-primary-only": r_prim.set_active(True)
        elif self.mode == "enforce-desktop": r_both.set_active(True)

        menu.append(Gtk.SeparatorMenuItem())
        item_sets = Gtk.MenuItem(label=_("‚öôÔ∏è Nastaven√≠"))
        item_sets.connect("activate", lambda _: self._launch_settings())
        menu.append(item_sets)

        item_check = Gtk.MenuItem(label=_("Zkontrolovat"))
        item_check.connect("activate", lambda _: self._run_check())
        menu.append(item_check)

        menu.append(Gtk.SeparatorMenuItem())

        item_quit = Gtk.MenuItem(label=_("Ukonƒçit"))
        item_quit.connect("activate", lambda _: self.Quit())
        menu.append(item_quit)

        menu.show_all()
        return menu

    def _setup_appindicator(self):
        self.indicator = AppIndicator.Indicator.new(
            APP_ID, ICON_NAME, AppIndicator.IndicatorCategory.HARDWARE
        )
        self._set_icon_by_mode()
        self.indicator.set_menu(self._build_menu())

    def _setup_sni(self):
        print(_("üîµ Inicializuji KDE StatusNotifierItem (SNI)"))
        self.sni = StatusNotifierItem(self)
        try:
            self.bus.register_object("/StatusNotifierItem", self.sni, None)
            self.tray_backend = "sni"
            self._set_icon_by_mode()
            print(_("‚úÖ SNI objekt vytvo≈ôen."))
        except Exception as e:
            print(_(f"‚ùå Chyba SNI: {e}"))
            raise e

    def register_sni_watcher(self):
        if self.tray_backend == "sni":
            try:
                watcher = self.bus.get("org.kde.StatusNotifierWatcher", "/StatusNotifierWatcher")
                watcher.RegisterStatusNotifierItem(BUS_NAME)
                print(_("‚úÖ SNI registrov√°no u KDE Watchera."))
                self.sni.NewIcon()
                self.sni.NewStatus()
            except Exception as e:
                print(_(f"‚ö†Ô∏è Watcher error: {e}"))

    def _show_gtk_menu(self, button):
        try:
            self.menu = self._build_menu()
            self.menu.show_all()
            self.menu.popup(None, None, None, None, 0, 0)
        except Exception as e:
            print(_(f"‚ùå Chyba p≈ôi zobrazov√°n√≠ menu: {e}"))
        return False


def is_kde():
    return os.environ.get("XDG_CURRENT_DESKTOP", "").lower() == "kde"

# --- Main Boilerplate ---
loop = None
publication = None

def quit_app(*args):
    global publication, loop
    print(_("\nüßπ Ukonƒçuji..."))
    if publication:
        try: publication.unpublish()
        except: pass
    if loop: Gtk.main_quit()
    sys.exit(0)

def signal_handler():
    # <--- NOV√â: Kontrola konfigurace pro sign√°ly (vƒçetnƒõ syst√©mov√©ho skriptu)
    if not agent.config["enable_signal"]:
        print(_("üì© Sign√°l SIGUSR1 ZAM√çTNUT (vypnuto v configu)."))
        return True

    if agent.mode == "automatic-enabled":
        print(_("üì© Sign√°l SIGUSR1 p≈ôijat!"))
        agent._run_check("Signal")
    else:
        print(_(f"üì© Sign√°l SIGUSR1 ignorov√°n (Re≈æim ze souboru: {agent.mode})."))
    return True

def sighup_handler():
    """Obsluha sign√°lu SIGHUP - Reload konfigurace."""
    print(_("üîÑ Sign√°l SIGHUP p≈ôijat: Znovunaƒç√≠t√°m konfiguraci..."))
    # Zavol√°me metodu agenta, kter√° naƒçte soubory znovu
    agent.config = agent._load_config()
    return True # Mus√≠ vracet True, aby naslouch√°n√≠ pokraƒçovalo

if __name__ == "__main__":
    bus = SessionBus()

    dbus_sys = bus.get("org.freedesktop.DBus", "/org/freedesktop/DBus")
    if dbus_sys.NameHasOwner(BUS_NAME):
        print(_(f"‚ö†Ô∏è Agent u≈æ bƒõ≈æ√≠."))
        sys.exit(0)

    agent = AsusAgent(quit_callback=quit_app, bus=bus)

    try:
        publication = bus.publish(BUS_NAME, agent)
        print(_(f"‚úÖ D-Bus jm√©no {BUS_NAME} z√≠sk√°no."))
        agent.register_sni_watcher()
    except Exception as e:
        print(_(f"‚ùå Start selhal: {e}"))
        sys.exit(1)

    GLib.unix_signal_add(GLib.PRIORITY_DEFAULT, signal.SIGUSR1, signal_handler)
    GLib.unix_signal_add(GLib.PRIORITY_DEFAULT, signal.SIGHUP, sighup_handler)
    GLib.unix_signal_add(GLib.PRIORITY_DEFAULT, signal.SIGTERM, quit_app)
    GLib.unix_signal_add(GLib.PRIORITY_DEFAULT, signal.SIGINT, quit_app)

    print(_(f"‚úÖ Asus Agent GUI spu≈°tƒõn."))
    print(_(f"   Re≈æim: {agent.mode}"))
    print(_(f"   PID: {os.getpid()}"))

    # Hlavn√≠ smyƒçka v bloku try/finally pro jistotu
    try:
        loop = Gtk.main()
    except KeyboardInterrupt:
        quit_app()
    finally:
        # Z√°chrann√° brzda, kdyby Gtk.main() spadlo jinak
        pass


================================================================================

üìÑ PATH: asus-screen-toggle/usr/bin/asus-check-rotation.sh
--------------------------------------------------------------------------------
#!/bin/bash

ROTATION=""

CHECH_BIN=$(command -v asus-check-keyboard-system || echo "/usr/bin/asus-check-keyboard-system")

monitor-sensor | while read -r line; do
  case "$line" in
    *"normal"*)      NEW_ROT="normal" ;;
    *"bottom-up"*)   NEW_ROT="inverted" ;;
    *"left-up"*)     NEW_ROT="left" ;;
    *"right-up"*)    NEW_ROT="right" ;;
    *) continue ;;  # jin√© informace ignorujeme
  esac

  if [[ "$NEW_ROT" != "$ROTATION" ]]; then
    ROTATION="$NEW_ROT"
    echo "Nov√° orientace: $ROTATION"
    echo "DIR=\"$line\"" > /tmp/asus-rotation
    $CHECH_BIN
  fi

  sleep 3
done


================================================================================

üìÑ PATH: asus-screen-toggle/src/bin/helpers.sh
--------------------------------------------------------------------------------
prepare_user_context() {
    local sid="$1"

    user=$(loginctl show-session "$sid" -p Name --value)
    type=$(loginctl show-session "$sid" -p Type --value)
    desktop=$(loginctl show-session "$sid" -p Desktop --value)
    state=$(loginctl show-session "$sid" -p State --value)

    [[ "$state" == "active" ]] || return 1
    [[ "$user" != "sddm" && "$user" != "gdm" && "$user" != "lightdm" ]] || return 1
    [[ "$type" == "x11" || "$type" == "wayland" ]] || return 1

    USER_UID=$(loginctl show-session "$sid" -p User --value)

    runtime_path=$(loginctl show-session "$sid" -p RuntimePath --value)
    [[ -z "$runtime_path" ]] && runtime_path="/run/user/$USER_UID"

    dbus_address="unix:path=$runtime_path/bus"

    USER_BIN=$(command -v asus-check-keyboard-user || echo "/usr/bin/asus-check-keyboard-user")

    return 0
}


================================================================================

üìÑ PATH: asus-screen-toggle/src/bin/channels/direct.sh
--------------------------------------------------------------------------------
if [[ "${ENABLE_DIRECT_CALL:-false}" == "true" ]]; then

    if [[ "$type" == "x11" ]]; then
        display=$(loginctl show-session "$sid" -p Display --value)
        xauth_file="/home/$user/.Xauthority"
        [[ -f "$xauth_file" ]] || return 1

        sudo -u "$user" \
            env DISPLAY="$display" \
                XDG_SESSION_ID="$sid" \
                XDG_SESSION_TYPE="$type" \
                XDG_CURRENT_DESKTOP="$desktop" \
                XDG_RUNTIME_DIR="$runtime_path" \
                DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
            "$USER_BIN"
    fi

    if [[ "$type" == "wayland" ]]; then
        wayland_disp=$(loginctl show-session "$sid" -p WaylandDisplay --value)
        [[ -z "$wayland_disp" ]] && wayland_disp="wayland-0"

        sudo -u "$user" \
            env WAYLAND_DISPLAY="$wayland_disp" \
                XDG_SESSION_ID="$sid" \
                XDG_SESSION_TYPE="$type" \
                XDG_CURRENT_DESKTOP="$desktop" \
                XDG_RUNTIME_DIR="$runtime_path" \
                DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
            "$USER_BIN"
    fi
fi


================================================================================

üìÑ PATH: asus-screen-toggle/src/bin/channels/signal.sh
--------------------------------------------------------------------------------
if [[ "${ENABLE_SIGNAL:-false}" == "true" ]]; then
    AGENT_PID=$(pgrep -u "$user" -f "asus-user-agent" | head -n 1)

    if [[ -n "$AGENT_PID" ]]; then
        kill -SIGUSR1 "$AGENT_PID"
        exit 0
    fi
fi


================================================================================

üìÑ PATH: asus-screen-toggle/src/bin/channels/dbus.sh
--------------------------------------------------------------------------------
if [[ "${ENABLE_DBUS:-false}" == "true" ]]; then
    if sudo -u "$user" DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
        dbus-send --session --print-reply --reply-timeout=1000 \
        --dest=org.asus.ScreenToggle \
        /org/asus/ScreenToggle org.asus.ScreenToggle.Trigger \
        > /dev/null 2>&1; then
        exit 0
    fi
fi


================================================================================

üìÑ PATH: asus-screen-toggle/src/bin/channels/systemd.sh
--------------------------------------------------------------------------------
if [[ "${ENABLE_SYSTEMD_CALL:-false}" == "true" ]]; then
    if systemctl --user --machine="$USER_UID@.host" \
        start asus-screen-toggle.service \
        > /dev/null 2>&1; then
        exit 0
    fi
fi


================================================================================

üìÑ PATH: asus-screen-toggle/src/bin/channels/noop-debug.sh
--------------------------------------------------------------------------------
log "NOOP dispatcher invoked with reason: $REASON"


================================================================================

üìÑ PATH: .qtc_clangd/compile_commands.json
--------------------------------------------------------------------------------
[]

================================================================================

üìÑ PATH: backup&devutils/detect-sessions.sh
--------------------------------------------------------------------------------
#!/bin/bash

echo "U≈æivatel | Session | Typ | Prost≈ôed√≠"

loginctl list-sessions --no-legend | while read sid user seat rest; do
    type=$(loginctl show-session "$sid" -p Type --value)
    display=$(loginctl show-session "$sid" -p Display --value)
    wayland=$(loginctl show-session "$sid" -p WaylandDisplay --value)

    env_type=0
    env_info="nelze zjistit"

    if [ "$type" = "tty" ]; then
        env_type=1
        env_info="textov√° konzole"
    elif [ "$type" = "x11" ]; then
        env_type=2
        env_info="DISPLAY=$display"
    elif [ "$type" = "wayland" ]; then
        env_type=3
        env_info="WAYLAND_DISPLAY=$wayland"
    fi

    echo "$user | $sid | $env_type | $env_info"
done

echo ""
echo "U≈æivatel√© v grafick√©m prost≈ôed√≠ (X11/Wayland):"
loginctl list-sessions --no-legend | while read sid user seat rest; do
    type=$(loginctl show-session "$sid" -p Type --value)
    if [[ "$type" == "x11" || "$type" == "wayland" ]]; then
        display=$(loginctl show-session "$sid" -p Display --value)
        wayland=$(loginctl show-session "$sid" -p WaylandDisplay --value)
        echo "$user | $sid | $type | DISPLAY=$display WAYLAND_DISPLAY=$wayland"
    fi
done


================================================================================

üìÑ PATH: backup&devutils/asus-check-keyboard.sh
--------------------------------------------------------------------------------
#!/bin/bash

max_tries=1
delay=15
attempt=0

# Identifikace kl√°vesnice (uprav podle pot≈ôeby)
VENDOR_ID="0B05"
PRODUCT_ID="1BF2"

# V√Ωstupn√≠ jm√©no displeje (zmƒõ≈à podle `kscreen-doctor -o`)
PRIMARY_DISPLAY_NAME="eDP-1"
SECONDARY_DISPLAY_NAME="eDP-2"

DIR=$(timeout 2 monitor-sensor --accel | grep orientation)
DISPLAY_ROTATION="normal"

KSCREEN_BIN=$(command -v kscreen-doctor || echo "/usr/bin/kscreen-doctor")

case "$DIR" in
*normal*)
    DISPLAY_ROTATION="normal"
    echo "qdbus org.kde.KWin /KWin setScreenRotation 0"
    ;;
*bottom-up*)
    DISPLAY_ROTATION="inverted"
    echo "qdbus org.kde.KWin /KWin setScreenRotation 180"
    ;;
*left-up*)
    DISPLAY_ROTATION="left"
    echo "qdbus org.kde.KWin /KWin setScreenRotation 270"
    ;;
*right-up*)
    DISPLAY_ROTATION="right"
    echo "qdbus org.kde.KWin /KWin setScreenRotation 90"
    ;;
esac

# while (( attempt < max_tries )); do
#     echo "‚è≥ Pokus $((attempt+1)) / $max_tries"

    sessions=$(loginctl list-sessions --no-legend | awk '{print $1}')
    for sid in $sessions; do
        user=$(loginctl show-session "$sid" -p Name --value)
        type=$(loginctl show-session "$sid" -p Type --value)

        if [[ "$type" == "x11" || "$user" == "sddm" ]]; then
            exit 0
        fi

        if [[ "$type" == "x11" || "$type" == "wayland" ]]; then
            USER_UID=$(loginctl show-session "$sid" -p User --value)
            runtime_dir=$(loginctl show-session "$sid" -p RuntimePath --value)
            runtime_dir="/run/user/$USER_UID"
            dbus_address="unix:path=$runtime_dir/bus"

            if [[ "$type" == "x11" ]]; then
                display=$(loginctl show-session "$sid" -p Display --value)
                xauth_file="/home/$user/.Xauthority"

                if [[ ! -f "$xauth_file" ]]; then
                    echo "‚ö†Ô∏è  XAUTHORITY nenalezen pro u≈æivatele $user. P≈ôeskoƒçeno."
                    continue
                fi

                echo "üü¢ Nalezen X11 u≈æivatel: $user"
                echo "sid=$sid"
                echo "DISPLAY=$display"
                echo "XDG_RUNTIME_DIR=$runtime_dir"

                # üí° Tady m≈Ø≈æe≈° d√°t X11-specifick√Ω p≈ô√≠kaz
                #sudo -u "$user" \
                #    env DISPLAY="$display" \
                #         XDG_RUNTIME_DIR="$runtime_dir" \
                #         DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                #    notify-send "X11 sezen√≠" "U≈æivatel $user je aktivn√≠ v X11"

                if lsusb | grep -iq "${VENDOR_ID}:${PRODUCT_ID}"; then
                    echo "Kl√°vesnice detekov√°na, vyp√≠n√°m spodn√≠ displej..."
                    sudo -u "$user" \
                        env DISPLAY="$display" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            XAUTHORITY="$xauth_file" \
                            xrandr --output ${SECONDARY_DISPLAY_NAME} --off
                else
                    echo "Kl√°vesnice nen√≠ p≈ôipojena, zap√≠n√°m spodn√≠ displej..."
                    sudo -u "$user" \
                        env DISPLAY="$display" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            XAUTHORITY="$xauth_file" \
                            xrandr --output ${SECONDARY_DISPLAY_NAME} --auto
                fi
            fi

            if [[ "$type" == "wayland" ]]; then
                wayland=$(loginctl show-session "$sid" -p WaylandDisplay --value)
                wayland=wayland-0
                echo "üü¢ Nalezen Wayland u≈æivatel: $user"
                echo "sid=$sid"
                echo "WAYLAND_DISPLAY=$wayland"
                echo "XDG_RUNTIME_DIR=$runtime_dir"

                # üí° Tady m≈Ø≈æe≈° d√°t Wayland-specifick√Ω p≈ô√≠kaz
                #sudo -u "$user" \
                #    env WAYLAND_DISPLAY="$wayland" \
                #         XDG_RUNTIME_DIR="$runtime_dir" \
                #         DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                #    notify-send "Wayland sezen√≠" "U≈æivatel $user je aktivn√≠ ve Waylandu"
                sudo -u "$user" \
                    env WAYLAND_DISPLAY="$wayland" \
                        XDG_RUNTIME_DIR="$runtime_dir" \
                        DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                        $KSCREEN_BIN output.${PRIMARY_DISPLAY_NAME}.rotation.${DISPLAY_ROTATION}

                if lsusb | grep -iq "${VENDOR_ID}:${PRODUCT_ID}"; then
                    echo "Kl√°vesnice detekov√°na, vyp√≠n√°m spodn√≠ displej..."
                    sudo -u "$user" \
                        env WAYLAND_DISPLAY="$wayland" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            $KSCREEN_BIN output.${SECONDARY_DISPLAY_NAME}.disable
                else
                    echo "Kl√°vesnice nen√≠ p≈ôipojena, zap√≠n√°m spodn√≠ displej..."
                    sudo -u "$user" \
                        env WAYLAND_DISPLAY="$wayland" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            $KSCREEN_BIN output.${SECONDARY_DISPLAY_NAME}.enable output.${SECONDARY_DISPLAY_NAME}.rotation.${DISPLAY_ROTATION}
                    # --- Z√≠sk√°n√≠ geometrie prim√°rn√≠ho v√Ωstupu ---
                    read PX PY PW PH <<< $(
                        sudo -u "$user" \
                            env WAYLAND_DISPLAY="$wayland" \
                                XDG_RUNTIME_DIR="$runtime_dir" \
                                DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                                kscreen-doctor -o | awk -v out="$output" '$0 ~ "Output: " && $0 ~ out { in_block=1; next } in_block && $0 ~ "Geometry:" { split($3, pos, ","); split($4, res, "x"); print pos[1], pos[2], res[1], res[2]; exit }')
                        echo "$PRIMARY_DISPLAY_NAME $PX,$PY,$PW,$PH"

                    # --- Z√≠sk√°n√≠ velikosti sekund√°rn√≠ho v√Ωstupu ---
                    read SX SY SW SH <<< $(
                        sudo -u "$user" \
                            env WAYLAND_DISPLAY="$wayland" \
                                XDG_RUNTIME_DIR="$runtime_dir" \
                                DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                                kscreen-doctor -o | awk -v out="$output" '$0 ~ "Output: " && $0 ~ out { in_block=1; next } in_block && $0 ~ "Geometry:" { split($3, pos, ","); split($4, res, "x"); print pos[1], pos[2], res[1], res[2]; exit }')
                    echo "$SECONDARY_DISPLAY_NAME $SX,$SY,$SW,$SH"

                    PX=0
                    PY=0

                    # --- V√Ωpoƒçet nov√© pozice ---
                    case "$DISPLAY_ROTATION" in
                        *left*)
                            PX=$(echo "$PX" | tr -dc '0-9')
                            SW=$(echo "$SW" | tr -dc '0-9')
                            SX=$((PX - SW))
                            SY=$PY
                            ;;
                        *right*)
                            PX=$(echo "$PX" | tr -dc '0-9')
                            PW=$(echo "$PW" | tr -dc '0-9')
                            SX=$((PX + PW))
                            SY=$PY
                            ;;
                        *inverted*)
                            SX=$PX
                            SY=$((PY - SH))
                            ;;
                        *normal*)
                            SX=$PX
                            SY=$((PY + PH))
                            ;;
                        *)
                            echo "Neplatn√° orientace: $DISPLAY_ROTATION"
                            exit 1
                            ;;
                    esac

                    echo "$PRIMARY_DISPLAY_NAME $PX,$PY,$PW,$PH"
                    echo "$SECONDARY_DISPLAY_NAME $SX,$SY,$SW,$SH"

                    # --- V√Ωstup a nastaven√≠ ---
                    echo "Um√≠s≈•uji $SECONDARY_DISPLAY_NAME $DISPLAY_ROTATIONod $PRIMARY_DISPLAY_NAME na sou≈ôadnice $SX,$SY"
                    sudo -u "$user" \
                        env WAYLAND_DISPLAY="$wayland" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            $KSCREEN_BIN output.$PRIMARY_DISPLAY_NAME.position.$PX,$PY output.${PRIMARY_DISPLAY_NAME}.rotation.${DISPLAY_ROTATION}
                    sudo -u "$user" \
                        env WAYLAND_DISPLAY="$wayland" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            $KSCREEN_BIN output.$SECONDARY_DISPLAY_NAME.position.$SX,$SY output.${SECONDARY_DISPLAY_NAME}.rotation.${DISPLAY_ROTATION}
                fi
            fi

            exit 0  # Ukonƒçit skript po prvn√≠m nalezen√©m GUI u≈æivateli
        fi
    done

#     if [[  (attempt  + 1) < max_tries ]]; then
#         echo "‚ùå ≈Ω√°dn√Ω aktivn√≠ X11/Wayland u≈æivatel. ƒåek√°m $delay s..."
#         (( attempt++ ))
#         sleep "$delay"
#     fi
# done

echo "‚ùå Nepoda≈ôilo se naj√≠t ≈æ√°dn√©ho u≈æivatele v GUI po $max_tries pokusech."
exit 0


================================================================================

üìÑ PATH: backup&devutils/asus-check-keyboard-wlr-randr.sh
--------------------------------------------------------------------------------
#!/bin/bash

# Identifikace kl√°vesnice (uprav podle pot≈ôeby)
VENDOR_ID="0B05"
PRODUCT_ID="1BF2"

# V√Ωstupn√≠ jm√©no displeje (zmƒõ≈à podle `kscreen-doctor -o`)
DISPLAY_NAME="eDP-2"

# UID u≈æivatele (uprav podle sv√©ho syst√©mu)
USER_UID=1000
XDG_SESSION_TYPE=wayland
WAYLAND_DISPLAY=wayland-0

# Nastaven√≠ prost≈ôed√≠
export XDG_RUNTIME_DIR="/run/user/$USER_UID"
export XDG_SESSION_TYPE=wayland
export WAYLAND_DISPLAY=wayland-0
export DISPLAY=:0

if lsusb | grep -iq "${VENDOR_ID}:${PRODUCT_ID}"; then
    echo "Kl√°vesnice detekov√°na, vyp√≠n√°m spodn√≠ displej..."
    wlr-randr --output ${DISPLAY_NAME} --off
else
    echo "Kl√°vesnice nen√≠ p≈ôipojena, zap√≠n√°m spodn√≠ displej..."
    wlr-randr --output ${DISPLAY_NAME} --on
fi


================================================================================

üìÑ PATH: backup&devutils/detect-sessions-message.sh
--------------------------------------------------------------------------------
#!/bin/bash

max_tries=5
delay=15
attempt=0

while (( attempt < max_tries )); do
    echo "‚è≥ Pokus $((attempt+1)) / $max_tries"

    sessions=$(loginctl list-sessions --no-legend | awk '{print $1}')
    for sid in $sessions; do
        user=$(loginctl show-session "$sid" -p Name --value)
        type=$(loginctl show-session "$sid" -p Type --value)

        if [[ "$type" == "x11" || "$type" == "wayland" ]]; then
            runtime_dir=$(loginctl show-session "$sid" -p RuntimePath --value)
            dbus_address="unix:path=$runtime_dir/bus"

            if [[ "$type" == "x11" ]]; then
                display=$(loginctl show-session "$sid" -p Display --value)

                echo "üü¢ Nalezen X11 u≈æivatel: $user"
                echo "sid=$sid"
                echo "DISPLAY=$display"
                echo "XDG_RUNTIME_DIR=$runtime_dir"

                # üí° Tady m≈Ø≈æe≈° d√°t X11-specifick√Ω p≈ô√≠kaz
                #sudo -u "$user" \
                #    env DISPLAY="$display" \
                #         XDG_RUNTIME_DIR="$runtime_dir" \
                #         DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                #    notify-send "X11 sezen√≠" "U≈æivatel $user je aktivn√≠ v X11"
            fi

            if [[ "$type" == "wayland" ]]; then
                wayland=$(loginctl show-session "$sid" -p WaylandDisplay --value)

                echo "üü¢ Nalezen Wayland u≈æivatel: $user"
                echo "sid=$sid"
                echo "WAYLAND_DISPLAY=$wayland"
                echo "XDG_RUNTIME_DIR=$runtime_dir"

                # üí° Tady m≈Ø≈æe≈° d√°t Wayland-specifick√Ω p≈ô√≠kaz
                #sudo -u "$user" \
                #    env WAYLAND_DISPLAY="$wayland" \
                #         XDG_RUNTIME_DIR="$runtime_dir" \
                #         DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                #    notify-send "Wayland sezen√≠" "U≈æivatel $user je aktivn√≠ ve Waylandu"
            fi

            exit 0  # Ukonƒçit skript po prvn√≠m nalezen√©m GUI u≈æivateli
        fi
    done

    echo "‚ùå ≈Ω√°dn√Ω aktivn√≠ X11/Wayland u≈æivatel. ƒåek√°m $delay s..."
    (( attempt++ ))
    sleep "$delay"
done

echo "‚ùå Nepoda≈ôilo se naj√≠t ≈æ√°dn√©ho u≈æivatele v GUI po $max_tries pokusech."
exit 0


================================================================================

üìÑ PATH: backup&devutils/asus-check-keyboard-xrandr.sh
--------------------------------------------------------------------------------
#!/bin/bash

# Identifikace kl√°vesnice (uprav podle pot≈ôeby)
VENDOR_ID="0B05"
PRODUCT_ID="1BF2"

# V√Ωstupn√≠ jm√©no displeje (zmƒõ≈à podle `kscreen-doctor -o`)
DISPLAY_NAME="eDP-2"

# UID u≈æivatele (uprav podle sv√©ho syst√©mu)
USER_UID=1000
XDG_SESSION_TYPE=wayland
WAYLAND_DISPLAY=wayland-0

# Nastaven√≠ prost≈ôed√≠
export XDG_RUNTIME_DIR="/run/user/$USER_UID"
export XDG_SESSION_TYPE=wayland
export WAYLAND_DISPLAY=wayland-0
export DISPLAY=:0

if lsusb | grep -iq "${VENDOR_ID}:${PRODUCT_ID}"; then
    echo "Kl√°vesnice detekov√°na, vyp√≠n√°m spodn√≠ displej..."
    xrandr --output ${DISPLAY_NAME} --off
else
    echo "Kl√°vesnice nen√≠ p≈ôipojena, zap√≠n√°m spodn√≠ displej..."
    xrandr --output ${DISPLAY_NAME} --auto
fi


================================================================================

üìÑ PATH: backup&devutils/asus-user-agent.sh
--------------------------------------------------------------------------------
#!/bin/bash

### 1. Singleton Check (Robustn√≠ verze s flock)
# Otev≈ôeme soubor z√°mku na deskriptoru 200
LOCKFILE="/tmp/asus-user-agent.lock"
exec 200> "$LOCKFILE"

# Pokus√≠me se z√≠skat exkluzivn√≠ z√°mek (-x) bez ƒçek√°n√≠ (-n).
# Pokud to nejde (jin√° instance u≈æ ho m√°), skonƒç√≠me.
if ! flock -n -x 200; then
    echo "Agent u≈æ bƒõ≈æ√≠ (z√°mek je aktivn√≠)."
    exit 1
fi

### 2. Konfigurace a Cesty
APP_NAME="asus-check-keyboard"
STATE_DIR="$HOME/.local/state/$APP_NAME"
STATE_FILE="$STATE_DIR/state"
LOGIC_SCRIPT="/usr/bin/asus-check-keyboard-user.sh"
ICON_PATH="/usr/share/asus-screen-toggle"

# Ikony (ujistƒõte se, ≈æe existuj√≠, jinak yad nezobraz√≠ nic)
ICON_AUTO="$ICON_PATH/icon-green.png"
ICON_PRIMARY="$ICON_PATH/icon-red.png"
ICON_DESKTOP="$ICON_PATH/icon-blue.png"
# Fallback ikony ze syst√©mu, kdyby va≈°e neexistovaly
[ -f "$ICON_AUTO" ] || ICON_AUTO="input-tablet"
[ -f "$ICON_PRIMARY" ] || ICON_PRIMARY="video-display"
[ -f "$ICON_DESKTOP" ] || ICON_DESKTOP="computer"

# Naƒçten√≠ configu (pokud existuje)
[ -f /etc/asus-check-keyboard.cfg ] && source /etc/asus-check-keyboard.cfg

### 3. P≈ô√≠prava roury (Pipe) pro YAD
PIPE=$(mktemp -u /tmp/asus_tray_XXXX.fifo)
mkfifo "$PIPE"
# Trik: Otev≈ôeme rouru na deskriptoru 3 pro ƒçten√≠ i z√°pis.
# To zajist√≠, ≈æe roura z≈Østane "≈æiv√°", i kdy≈æ do n√≠ nikdo zrovna nep√≠≈°e.
exec 3<> "$PIPE"

# √öklid p≈ôi ukonƒçen√≠
cleanup() {
    rm -f "$PIPE"
    kill $YAD_PID 2>/dev/null
    exit 0
}
trap cleanup SIGINT SIGTERM EXIT

### 4. Funkce pro nastaven√≠ stavu a ikony
update_tray() {
    # 1. P≈ôeƒç√≠st stav (buƒè z argumentu, nebo ze souboru)
    if [ -n "$1" ]; then
        CURRENT_STATE="$1"
        # Ulo≈æit nov√Ω stav
        mkdir -p "$STATE_DIR"
        echo "$CURRENT_STATE" > "$STATE_FILE"
    elif [ -f "$STATE_FILE" ]; then
        CURRENT_STATE=$(<"$STATE_FILE")
    else
        CURRENT_STATE="automatic-enabled"
    fi

    echo "Stav: $CURRENT_STATE"

    # 2. Poslat p≈ô√≠kazy do YADu p≈ôes rouru (fd 3)
    case "$CURRENT_STATE" in
        automatic-enabled)
            echo "icon:$ICON_AUTO" >&3
            echo "tooltip:Automaticky re≈æim" >&3
            ;;
        enforce-primary-only)
            echo "icon:$ICON_PRIMARY" >&3
            echo "tooltip:Vynuceno: Jen prim√°rn√≠" >&3
            ;;
        enforce-desktop)
            echo "icon:$ICON_DESKTOP" >&3
            echo "tooltip:Vynuceno: Desktop m√≥d" >&3
            ;;
    esac
}

# Funkce, kter√° provede logiku p≈ôepnut√≠ obrazovek
apply_logic() {
    echo "Spou≈°t√≠m logiku obrazovek..."
    bash "$LOGIC_SCRIPT" &
}

### 5. Zpracov√°n√≠ kliknut√≠ z menu (Bƒõ≈æ√≠ na pozad√≠)
handle_click() {
    local action="$1"
    echo "Kliknuto: $action"
    case "$action" in
        set_auto)
            update_tray "automatic-enabled"
            apply_logic
            ;;
        set_primary)
            update_tray "enforce-primary-only"
            apply_logic
            ;;
        set_desktop)
            update_tray "enforce-desktop"
            apply_logic
            ;;
        trigger_check)
            # Jen spust√≠me kontrolu (nap≈ô. sign√°l od Udevu)
            apply_logic
            # Po kontrole se m≈Ø≈æe zmƒõnit stav (nap≈ô. detekce rotace),
            # ale to by mƒõl ≈ôe≈°it logic script z√°pisem do state file?
            # Pro jistotu jen p≈ôekresl√≠me ikonu dle aktu√°ln√≠ho souboru
            update_tray
            ;;
        quit)
            cleanup
            exit 0
            ;;
    esac
}

### 6. Spu≈°tƒõn√≠ YAD (Tray Icon)
# GDK_BACKEND=x11: Nutn√© pro Wayland, jinak se nezobraz√≠ ikona
# <&3 : ƒåte p≈ô√≠kazy z na≈°√≠ roury
# > >(...) : V√Ωstup (kliknut√≠) pos√≠l√°me rovnou do smyƒçky, kter√° vol√° handle_click
env GDK_BACKEND=x11 yad --notification --listen \
    --image="$ICON_AUTO" \
    --text="ASUS Control" \
    --menu="Automaticky ! echo set_auto | \
            Jen prim√°rn√≠ ! echo set_primary | \
            Desktop m√≥d ! echo set_desktop | \
            Zkontrolovat ! echo trigger_check | \
            Ukonƒçit ! echo quit" \
    <&3 > >(while read -r line; do handle_click "$line"; done) &

YAD_PID=$!

### 7. Hlavn√≠ smyƒçka a Sign√°ly
# Kdy≈æ Udev po≈°le SIGUSR1, p≈ôekresl√≠me tray a spust√≠me logiku
trap 'update_tray; apply_logic' SIGUSR1

echo "Agent spu≈°tƒõn (PID $$). YAD PID: $YAD_PID"

# Inicializace stavu po startu
update_tray

# HLAVN√ç SMYƒåKA
# 'wait' se ukonƒç√≠ p≈ôi ka≈æd√©m sign√°lu (SIGUSR1).
# Proto ho vol√°me ve smyƒçce, dokud proces YAD skuteƒçnƒõ bƒõ≈æ√≠.
while kill -0 $YAD_PID 2>/dev/null; do
    wait $YAD_PID
done

# √öklid, pokud YAD spadne s√°m od sebe
rm -f "$PIPE


================================================================================

üìÑ PATH: backup&devutils/asus-check-keyboard-kscreen.sh
--------------------------------------------------------------------------------
#!/bin/bash

# Identifikace kl√°vesnice (uprav podle pot≈ôeby)
VENDOR_ID="0B05"
PRODUCT_ID="1BF2"

# V√Ωstupn√≠ jm√©no displeje (zmƒõ≈à podle `kscreen-doctor -o`)
DISPLAY_NAME="eDP-2"

# UID u≈æivatele (uprav podle sv√©ho syst√©mu)
USER_UID=1000
XDG_SESSION_TYPE=wayland
WAYLAND_DISPLAY=wayland-0

# Nastaven√≠ prost≈ôed√≠
export XDG_RUNTIME_DIR="/run/user/$USER_UID"
export XDG_SESSION_TYPE=wayland
export WAYLAND_DISPLAY=wayland-0
export DISPLAY=:0

if lsusb | grep -iq "${VENDOR_ID}:${PRODUCT_ID}"; then
    echo "Kl√°vesnice detekov√°na, vyp√≠n√°m spodn√≠ displej..."
    /usr/bin/kscreen-doctor output.${DISPLAY_NAME}.disable
else
    echo "Kl√°vesnice nen√≠ p≈ôipojena, zap√≠n√°m spodn√≠ displej..."
    /usr/bin/kscreen-doctor output.${DISPLAY_NAME}.enable
fi


================================================================================

üìÑ PATH: backup&devutils/screen_size.sh
--------------------------------------------------------------------------------
#!/bin/bash

# --- Nastaven√≠ ---
PRIMARY="eDP-1"
SECONDARY="DP-10"
ORIENTATION="$1"  # left, right, above, below

if [[ -z "$ORIENTATION" ]]; then
    echo "Pou≈æit√≠: $0 [left|right|above|below]"
    #exit 1
fi

# --- Funkce pro z√≠sk√°n√≠ geometrie z blokov√©ho v√Ωpisu ---
get_geometry_block() {
    local output="$1"
    #kscreen-doctor -o | awk -v out="eDP-1" '$0 ~ "Output: " && $0 ~ out { in_block=1; next } in_block && $0 ~ "Geometry:" { print; exit }'
    #kscreen-doctor -o | awk -v out="eDP-1" '$0 ~ "Output: " && $0 ~ out { in_block=1; next } in_block && $0 ~ "Geometry:" { print; split($2, pos, ","); split($3, res, "x"); print pos[1], pos[2], res[1], res[2]; exit }'
    kscreen-doctor -o | awk -v out="$output" '$0 ~ "Output: " && $0 ~ out { in_block=1; next } in_block && $0 ~ "Geometry:" { split($3, pos, ","); split($4, res, "x"); print pos[1], pos[2], res[1], res[2]; exit }'
}

# --- Z√≠sk√°n√≠ geometrie ---
read PX PY PW PH <<< "$(get_geometry_block "$PRIMARY")" || {
    echo "Chyba: nelze zjistit geometrii prim√°rn√≠ho v√Ωstupu $PRIMARY"
    exit 1
}

read SX SY SW SH <<< "$(get_geometry_block "$SECONDARY")"
if [[ -z "$SW" || -z "$SH" ]]; then
    echo "Upozornƒõn√≠: Sekund√°rn√≠ v√Ωstup $SECONDARY nen√≠ aktivn√≠, pou≈æiji 1440x900"
    SW=1440
    SH=900
fi

echo "Primary   >$PX<, >$PY<, >$PW<, >$PH<"
echo "Secondary >$SX<, >$SY<, >$SW<, >$SH<"

# --- V√Ωpoƒçet nov√© pozice ---
case "$ORIENTATION" in
    left)
        NX=$((PX - SW))
        NY=$PY
        ;;
    right)
        NX=$((PX + PW))
        NY=$PY
        ;;
    above)
        NX=$PX
        NY=$((PY - SH))
        ;;
    below)
        NX=$PX
        NY=$((PY + PH))
        ;;
    *)
        echo "Neplatn√° orientace: $ORIENTATION"
        exit 1
        ;;
esac

# --- V√Ωstup a aplikace ---
echo "Um√≠s≈•uji $SECONDARY $ORIENTATION od $PRIMARY na pozici $NX,$NY"
#kscreen-doctor output.$SECONDARY.enable output.$SECONDARY.position.$NX,$NY


================================================================================

üìÑ PATH: backup&devutils/asus-check-keyboard-kscreen-and-xrandr.sh
--------------------------------------------------------------------------------
#!/bin/bash

max_tries=1
delay=15
attempt=0

# Identifikace kl√°vesnice (uprav podle pot≈ôeby)
VENDOR_ID="0B05"
PRODUCT_ID="1BF2"

# V√Ωstupn√≠ jm√©no displeje (zmƒõ≈à podle `kscreen-doctor -o`)
DISPLAY_NAME="eDP-2"

# while (( attempt < max_tries )); do
#     echo "‚è≥ Pokus $((attempt+1)) / $max_tries"

    sessions=$(loginctl list-sessions --no-legend | awk '{print $1}')
    for sid in $sessions; do
        user=$(loginctl show-session "$sid" -p Name --value)
        type=$(loginctl show-session "$sid" -p Type --value)

        if [[ "$type" == "x11" || "$user" == "sddm" ]]; then
            exit 0
        fi

        if [[ "$type" == "x11" || "$type" == "wayland" ]]; then
            USER_UID=$(loginctl show-session "$sid" -p User --value)
            runtime_dir=$(loginctl show-session "$sid" -p RuntimePath --value)
            runtime_dir="/run/user/$USER_UID"
            dbus_address="unix:path=$runtime_dir/bus"

            if [[ "$type" == "x11" ]]; then
                display=$(loginctl show-session "$sid" -p Display --value)
                xauth_file="/home/$user/.Xauthority"

                if [[ ! -f "$xauth_file" ]]; then
                    echo "‚ö†Ô∏è  XAUTHORITY nenalezen pro u≈æivatele $user. P≈ôeskoƒçeno."
                    continue
                fi

                echo "üü¢ Nalezen X11 u≈æivatel: $user"
                echo "sid=$sid"
                echo "DISPLAY=$display"
                echo "XDG_RUNTIME_DIR=$runtime_dir"

                # üí° Tady m≈Ø≈æe≈° d√°t X11-specifick√Ω p≈ô√≠kaz
                #sudo -u "$user" \
                #    env DISPLAY="$display" \
                #         XDG_RUNTIME_DIR="$runtime_dir" \
                #         DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                #    notify-send "X11 sezen√≠" "U≈æivatel $user je aktivn√≠ v X11"

                if lsusb | grep -iq "${VENDOR_ID}:${PRODUCT_ID}"; then
                    echo "Kl√°vesnice detekov√°na, vyp√≠n√°m spodn√≠ displej..."
                    sudo -u "$user" \
                        env DISPLAY="$display" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            XAUTHORITY="$xauth_file" \
                            xrandr --output ${DISPLAY_NAME} --off
                else
                    echo "Kl√°vesnice nen√≠ p≈ôipojena, zap√≠n√°m spodn√≠ displej..."
                    sudo -u "$user" \
                        env DISPLAY="$display" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            XAUTHORITY="$xauth_file" \
                            xrandr --output ${DISPLAY_NAME} --auto
                fi
            fi

            if [[ "$type" == "wayland" ]]; then
                wayland=$(loginctl show-session "$sid" -p WaylandDisplay --value)
                wayland=wayland-0
                echo "üü¢ Nalezen Wayland u≈æivatel: $user"
                echo "sid=$sid"
                echo "WAYLAND_DISPLAY=$wayland"
                echo "XDG_RUNTIME_DIR=$runtime_dir"

                # üí° Tady m≈Ø≈æe≈° d√°t Wayland-specifick√Ω p≈ô√≠kaz
                #sudo -u "$user" \
                #    env WAYLAND_DISPLAY="$wayland" \
                #         XDG_RUNTIME_DIR="$runtime_dir" \
                #         DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                #    notify-send "Wayland sezen√≠" "U≈æivatel $user je aktivn√≠ ve Waylandu"
                if lsusb | grep -iq "${VENDOR_ID}:${PRODUCT_ID}"; then
                    echo "Kl√°vesnice detekov√°na, vyp√≠n√°m spodn√≠ displej..."
                    sudo -u "$user" \
                        env WAYLAND_DISPLAY="$wayland" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            /usr/bin/kscreen-doctor output.${DISPLAY_NAME}.disable
                else
                    echo "Kl√°vesnice nen√≠ p≈ôipojena, zap√≠n√°m spodn√≠ displej..."
                    sudo -u "$user" \
                        env WAYLAND_DISPLAY="$wayland" \
                            XDG_RUNTIME_DIR="$runtime_dir" \
                            DBUS_SESSION_BUS_ADDRESS="$dbus_address" \
                            /usr/bin/kscreen-doctor output.${DISPLAY_NAME}.enable
                fi
            fi

            exit 0  # Ukonƒçit skript po prvn√≠m nalezen√©m GUI u≈æivateli
        fi
    done

#     if [[  (attempt  + 1) < max_tries ]]; then
#         echo "‚ùå ≈Ω√°dn√Ω aktivn√≠ X11/Wayland u≈æivatel. ƒåek√°m $delay s..."
#         (( attempt++ ))
#         sleep "$delay"
#     fi
# done

echo "‚ùå Nepoda≈ôilo se naj√≠t ≈æ√°dn√©ho u≈æivatele v GUI po $max_tries pokusech."
exit 0


================================================================================

